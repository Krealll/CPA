; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26732.1 

	TITLE	d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	??_C@_0CE@HIODEGAO@D?3?2Java?2CacheAssociativity?2file@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0M@JBCCIHLB@?5time?5is?5?9?5@		; `string'
PUBLIC	??_C@_04EPNKNKMC@For?5@				; `string'
PUBLIC	??_C@_0BA@DDIGICPA@Something?5wrong@		; `string'
PUBLIC	??_C@_05PDJBBECF@pause@				; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	?arr@@3PAUELEMENT@@A				; arr
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:PROC
EXTRN	__imp_?always_noconv@codecvt_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	__imp_?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z:PROC
EXTRN	__imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z:PROC
EXTRN	__imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ:PROC
EXTRN	__imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PAD1AAPAD@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp___get_stream_buffer_pointers:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp___fseeki64:PROC
EXTRN	__imp__fread:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp___Query_perf_counter:PROC
EXTRN	__imp__fsetpos:PROC
EXTRN	__imp____std_terminate:PROC
EXTRN	__imp__ungetc:PROC
EXTRN	__imp__setvbuf:PROC
EXTRN	__imp__fgetpos:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp___lock_file:PROC
EXTRN	__imp___unlock_file:PROC
EXTRN	__imp__system:PROC
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp__fgetc:PROC
EXTRN	__imp____std_exception_copy:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z:PROC
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp___Query_perf_frequency:PROC
EXTRN	__imp__fclose:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fputc:PROC
EXTRN	__imp____std_exception_destroy:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp____CxxFrameHandler3:PROC
?arr@@3PAUELEMENT@@A DB 0380000H DUP (?)		; arr
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
_BSS	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
	DD	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause@
CONST	SEGMENT
??_C@_05PDJBBECF@pause@ DB 'pause', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DDIGICPA@Something?5wrong@
CONST	SEGMENT
??_C@_0BA@DDIGICPA@Something?5wrong@ DB 'Something wrong', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EPNKNKMC@For?5@
CONST	SEGMENT
??_C@_04EPNKNKMC@For?5@ DB 'For ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JBCCIHLB@?5time?5is?5?9?5@
CONST	SEGMENT
??_C@_0M@JBCCIHLB@?5time?5is?5?9?5@ DB ' time is - ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HIODEGAO@D?3?2Java?2CacheAssociativity?2file@
CONST	SEGMENT
??_C@_0CE@HIODEGAO@D?3?2Java?2CacheAssociativity?2file@ DB 'D:\Java\Cache'
	DB	'Associativity\file.txt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ; std::forward<std::_Facet_base * &>
PUBLIC	??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$?0NX@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1> >::duration<double,std::ratio<1,1> ><double,void>
PUBLIC	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
PUBLIC	?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get
PUBLIC	?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter
PUBLIC	?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEXI@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2
PUBLIC	??$_Refancy@PAD$0A@@std@@YAPADPAD@Z		; std::_Refancy<char *,0>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPBV?$codecvt@DDU_Mbstatet@@@0@ABV10@@Z ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
PUBLIC	??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
PUBLIC	??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$duration_cast@V?$duration@NU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,void>
PUBLIC	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::is_open
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	??$_Max_value@I@std@@YAABIABI0@Z		; std::_Max_value<unsigned int>
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?zero@?$duration_values@_J@chrono@std@@SA_JXZ	; std::chrono::duration_values<__int64>::zero
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
PUBLIC	?is_open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ofstream<char,std::char_traits<char> >::is_open
PUBLIC	?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::open
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::zero
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
PUBLIC	?initialize@@YAXH@Z				; initialize
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	_main
PUBLIC	??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z		; std::_Ungetc<char>
PUBLIC	??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?not_eof@?$char_traits@D@std@@SAHABH@Z		; std::char_traits<char>::not_eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?move@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::move
PUBLIC	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::copy
PUBLIC	?length@?$char_traits@D@std@@SAIQBD@Z		; std::char_traits<char>::length
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	__real@41cdcd6500000000
PUBLIC	__real@45800000
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___std_terminate:PROC
EXTRN	__alldiv:PROC
EXTRN	__alldvrm:PROC
EXTRN	__allmul:PROC
EXTRN	__ltod3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
_BSS	ENDS
;	COMDAT __real@45800000
CONST	SEGMENT
__real@45800000 DD 045800000r			; 4096
CONST	ENDS
;	COMDAT __real@41cdcd6500000000
CONST	SEGMENT
__real@41cdcd6500000000 DQ 041cdcd6500000000r	; 1e+09
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$1
	DD	00H
	DD	FLAT:__unwindfunclet$_main$2
	DD	01H
	DD	FLAT:__unwindfunclet$_main$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	03H
	DD	FLAT:__unwindfunclet$_main$5
	DD	03H
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$1
	DD	00H
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT
; __Size$dead$ = ecx
; __Where$ = edx

; 186  :         (void)_Size;
; 187  :         return _Where;

	mov	eax, edx

; 188  :     }

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 62   :     {

	push	ebp
	mov	ebp, esp

; 63   :         _Data._What = _Message;

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [ecx+4], xmm0
	mov	DWORD PTR [ecx+4], eax

; 64   :     }

	mov	eax, ecx
	pop	ebp
	ret	8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 68   :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR __Other$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8

; 70   :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx

; 87   :     }

	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 91   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
	test	ecx, ecx
	cmovne	eax, ecx

; 92   :     }

	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 617  : 		return (INT_MAX);

	mov	eax, 2147483647				; 7fffffffH

; 618  : 		}

	ret	0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIQBD@Z
_TEXT	SEGMENT
?length@?$char_traits@D@std@@SAIQBD@Z PROC		; std::char_traits<char>::length, COMDAT
; __First$ = ecx

; 461  : #if _HAS_CXX17
; 462  : 		return (__builtin_strlen(_First));
; 463  : #else /* _HAS_CXX17 */
; 464  : 		return (_CSTD strlen(_First));

	lea	edx, DWORD PTR [ecx+1]
$LL3@length:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL3@length
	sub	ecx, edx
	mov	eax, ecx

; 465  : #endif /* _HAS_CXX17 */
; 466  : 		}

	ret	0
?length@?$char_traits@D@std@@SAIQBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::copy, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 470  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	DWORD PTR __Count$[ebp]
	push	edx
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 472  : 		}

	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?move@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::move, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 494  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	DWORD PTR __Count$[ebp]
	push	edx
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 496  : 		}

	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 506  : 		_Left = _Right;

	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 507  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT
; __Meta$ = ecx

; 521  : 		return (static_cast<char>(_Meta));

	mov	al, BYTE PTR [ecx]

; 522  : 		}

	ret	0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT
; __Ch$ = ecx

; 526  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [ecx]

; 527  : 		}

	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 531  : 		return (_Left == _Right);

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	sete	al

; 532  : 		}

	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT
?not_eof@?$char_traits@D@std@@SAHABH@Z PROC		; std::char_traits<char>::not_eof, COMDAT
; __Meta$ = ecx

; 535  : 		{	// return anything but EOF

	mov	eax, DWORD PTR [ecx]

; 536  : 		return (_Meta != eof() ? _Meta : !eof());

	xor	ecx, ecx
	cmp	eax, -1
	cmove	eax, ecx

; 537  : 		}

	ret	0
?not_eof@?$char_traits@D@std@@SAHABH@Z ENDP		; std::char_traits<char>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 541  : 		return (EOF);

	or	eax, -1

; 542  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 43   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$dead$ = ecx

; 54   : 		}

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT
; __Count$ = ecx

; 38   : 	return (_Count);

	mov	eax, ecx

; 39   : 	}

	ret	0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT
; __Bytes$ = ecx

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 53   : 		}

	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT
; __Ptr$ = ecx
; __Bytes$ = edx

; 115  : 	_Bytes += _Non_user_size;

	add	DWORD PTR [edx], 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax-4]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN7@Adjust_man

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	DWORD PTR [ecx], edx

; 134  : 	}

	ret	0
$LN7@Adjust_man:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vcruntime_typeinfo.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 131  :     {

	xorps	xmm0, xmm0

; 132  :     }

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vcruntime_exception.h

; 61   :         : _Data()

	movq	QWORD PTR [ecx+4], xmm0

; 62   :     {
; 63   :         _Data._What = _Message;

	mov	DWORD PTR [ecx+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast@
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vcruntime_typeinfo.h

; 131  :     {

	mov	DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@

; 132  :     }

	ret	0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 408  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1locale@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 409  : 		if (_Ptr != nullptr)

	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	je	SHORT $LN4@locale

; 410  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN4@locale
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN4@locale:

; 411  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1locale@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1locale@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 435  : 		{	// look up a facet in locale object

	push	ebp
	mov	ebp, esp

; 436  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR __Id$[ebp]
	cmp	esi, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Getfacet
	mov	eax, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+esi*4]

; 437  : 			? _Ptr->_Facetvec[_Id] : nullptr;	// null if id off end
; 438  : 		if (_Facptr != nullptr || !_Ptr->_Xparent)

	test	eax, eax
	jne	SHORT $LN3@Getfacet
	jmp	SHORT $LN10@Getfacet
$LN6@Getfacet:

; 436  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	xor	eax, eax
$LN10@Getfacet:

; 437  : 			? _Ptr->_Facetvec[_Id] : nullptr;	// null if id off end
; 438  : 		if (_Facptr != nullptr || !_Ptr->_Xparent)

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN3@Getfacet

; 439  : 			return (_Facptr);	// found facet or not transparent
; 440  : 		else
; 441  : 			{	// look in current locale
; 442  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

	call	DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 443  : 			return (_Id < _Ptr0->_Facetcount

	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN8@Getfacet
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 444  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 445  : 				: nullptr);	// no entry in current locale
; 446  : 			}
; 447  : 		}

	pop	ebp
	ret	4
$LN8@Getfacet:

; 443  : 			return (_Id < _Ptr0->_Facetcount

	xor	eax, eax
$LN3@Getfacet:
	pop	esi

; 444  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 445  : 				: nullptr);	// no entry in current locale
; 446  : 			}
; 447  : 		}

	pop	ebp
	ret	4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
;	COMDAT ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
_TEXT	SEGMENT
__Freq$2$ = -12						; size = 4
tv212 = -8						; size = 4
___$ReturnUdt$1$ = -4					; size = 4
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ PROC ; std::chrono::steady_clock::now, COMDAT
; ___$ReturnUdt$ = ecx

; 799  : 		{	// get current time

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR ___$ReturnUdt$1$[esp+24], ecx

; 800  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

	call	DWORD PTR __imp___Query_perf_frequency
	mov	ebx, eax
	mov	edi, edx
	mov	DWORD PTR __Freq$2$[esp+24], ebx

; 801  : 		const long long _Ctr = _Query_perf_counter();

	call	DWORD PTR __imp___Query_perf_counter

; 802  : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 803  : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 804  : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

	push	ebx
	push	edi
	push	ebx
	push	edx
	push	eax
	call	__alldvrm
	mov	esi, ebx
	pop	ebx
	push	0
	push	1000000000				; 3b9aca00H
	push	esi
	push	ecx
	mov	DWORD PTR tv212[esp+40], eax
	mov	ebx, edx
	call	__allmul
	push	edi
	push	DWORD PTR __Freq$2$[esp+28]
	push	edx
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	ebx
	push	DWORD PTR tv212[esp+36]
	mov	esi, eax
	mov	edi, edx
	call	__allmul

; 805  : 		return (time_point(duration(_Whole + _Part)));

	add	esi, eax

; 210  : 		: _MyDur(_Other)

	mov	eax, DWORD PTR ___$ReturnUdt$1$[esp+24]

; 805  : 		return (time_point(duration(_Whole + _Part)));

	adc	edi, edx

; 210  : 		: _MyDur(_Other)

	mov	DWORD PTR [eax+4], edi

; 806  : 		}

	pop	edi

; 210  : 		: _MyDur(_Other)

	mov	DWORD PTR [eax], esi

; 806  : 		}

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ENDP ; std::chrono::steady_clock::now
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT
; __Byte$ = ecx
; __File$ = edx

; 59   : 	{	// get a char element from a C stream

	push	esi

; 60   : 	int _Meta;
; 61   : 	if ((_Meta = _CSTD fgetc(_File)) == EOF)

	push	edx
	mov	esi, ecx
	call	DWORD PTR __imp__fgetc
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN2@Fgetc

; 62   : 		return (false);

	xor	al, al
	pop	esi

; 67   : 		}
; 68   : 	}

	ret	0
$LN2@Fgetc:

; 63   : 	else
; 64   : 		{	// got one, convert to char
; 65   : 		_Byte = (char)_Meta;

	mov	BYTE PTR [esi], al

; 66   : 		return (true);

	mov	al, 1
	pop	esi

; 67   : 		}
; 68   : 	}

	ret	0
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT
; __Byte$ = cl
; __File$ = edx

; 105  : 	return (_CSTD fputc(_Byte, _File) != EOF);

	push	edx
	movsx	eax, cl
	push	eax
	call	DWORD PTR __imp__fputc
	add	esp, 8
	cmp	eax, -1
	setne	al

; 106  : 	}

	ret	0
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z
_TEXT	SEGMENT
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT
; __Byte$ = ecx
; __File$ = edx

; 129  : 	return (_CSTD ungetc((unsigned char)_Byte, _File) != EOF);

	movzx	eax, BYTE PTR [ecx]
	push	edx
	push	eax
	call	DWORD PTR __imp__ungetc
	add	esp, 8
	cmp	eax, -1
	setne	al

; 130  : 	}

	ret	0
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp
;	COMDAT _main
_TEXT	SEGMENT
_t$17 = -320						; size = 64
$T12 = -256						; size = 8
$T11 = -248						; size = 8
$T10 = -240						; size = 8
$T9 = -232						; size = 8
_start$18 = -224					; size = 8
$T3 = -216						; size = 8
_end$19 = -216						; size = 8
_time$20 = -208						; size = 8
__Pn$21 = -204						; size = 4
_this$ = -204						; size = 4
tv814 = -200						; size = 4
__Pb$22 = -200						; size = 4
$T1 = -200						; size = 4
_N$1$ = -196						; size = 4
__Nr$23 = -196						; size = 4
_out$ = -192						; size = 176
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 45   : {	

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$_main
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 308				; 00000134H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	176					; 000000b0H
	lea	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 1079 : 		{	// construct unopened

	mov	DWORD PTR _out$[ebp], OFFSET ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
	lea	ecx, DWORD PTR _out$[ebp+104]
	call	DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
	push	0
	push	0
	lea	eax, DWORD PTR _out$[ebp+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	lea	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR $T1[ebp], 1
	call	DWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _out$[ebp+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-104]
	mov	DWORD PTR _out$[ebp+ecx-4], eax
	lea	eax, DWORD PTR _out$[ebp+4]

; 166  : 		: _Mysb()

	mov	ecx, eax

; 1079 : 		{	// construct unopened

	mov	DWORD PTR _this$[ebp], eax

; 166  : 		: _Mysb()

	call	DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 720  : 		_Mysb::_Init();	// initialize stream buffer base object

	lea	ecx, DWORD PTR _out$[ebp+4]

; 167  : 		{	// construct from pointer to C stream

	mov	DWORD PTR _out$[ebp+4], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 717  : 		_Closef = _Which == _Openfl;

	mov	BYTE PTR _out$[ebp+76], 0

; 718  : 		_Wrotesome = false;

	mov	BYTE PTR _out$[ebp+65], 0

; 719  : 
; 720  : 		_Mysb::_Init();	// initialize stream buffer base object

	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 739  : 		_State = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR _out$[ebp+68], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR _out$[ebp+80], 0
	mov	DWORD PTR _out$[ebp+72], eax

; 740  : 		_Pcvt = nullptr;	// pointer to codecvt facet

	mov	DWORD PTR _out$[ebp+60], 0

; 288  : 		if (_Myfile != nullptr || (_File = _Fiopen(_Filename, _Mode, _Prot)) == nullptr)

	push	64					; 00000040H
	push	2
	push	OFFSET ??_C@_0CE@HIODEGAO@D?3?2Java?2CacheAssociativity?2file@
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp

; 46   : 	ofstream out;

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 288  : 		if (_Myfile != nullptr || (_File = _Fiopen(_Filename, _Mode, _Prot)) == nullptr)

	call	DWORD PTR __imp_?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	je	$LN33@main

; 720  : 		_Mysb::_Init();	// initialize stream buffer base object

	lea	ecx, DWORD PTR _out$[ebp+4]
	mov	BYTE PTR _out$[ebp+76], 1
	mov	BYTE PTR _out$[ebp+65], 0
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 721  : 
; 722  : 		if (_File != nullptr && sizeof (_Elem) == 1)
; 723  : 			{	// point inside C stream with [first, first + count) buffer
; 724  : 			_Elem **_Pb = nullptr;
; 725  : 			_Elem **_Pn = nullptr;
; 726  : 			int *_Nr = nullptr;
; 727  : 
; 728  : 			::_get_stream_buffer_pointers(

	lea	eax, DWORD PTR __Nr$23[ebp]
	mov	DWORD PTR __Pb$22[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pn$21[ebp]
	mov	DWORD PTR __Pn$21[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pb$22[ebp]
	mov	DWORD PTR __Nr$23[ebp], 0
	push	eax
	push	esi
	call	DWORD PTR __imp___get_stream_buffer_pointers

; 729  : 				_File,
; 730  : 				reinterpret_cast<char***>(&_Pb),
; 731  : 				reinterpret_cast<char***>(&_Pn),
; 732  : 				&_Nr);
; 733  : 			int *_Nw = _Nr;
; 734  : 
; 735  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);

	mov	edx, DWORD PTR __Nr$23[ebp]
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __Pn$21[ebp]
	mov	eax, DWORD PTR __Pb$22[ebp]
	push	edx
	push	ecx
	push	eax
	push	edx
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _out$[ebp+4]
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z

; 739  : 		_State = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 292  : 		_Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	lea	ecx, DWORD PTR _out$[ebp+4]

; 739  : 		_State = _Stinit;

	mov	DWORD PTR _out$[ebp+68], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR _out$[ebp+72], eax

; 292  : 		_Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	lea	eax, DWORD PTR $T3[ebp]
	push	eax

; 738  : 		_Myfile = _File;

	mov	DWORD PTR _out$[ebp+80], esi

; 740  : 		_Pcvt = nullptr;	// pointer to codecvt facet

	mov	DWORD PTR _out$[ebp+60], 0

; 292  : 		_Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	call	DWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	call	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
	mov	esi, eax

; 785  : 		if (_Newcvt.always_noconv())

	mov	ecx, esi
	call	DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN40@main

; 786  : 			_Pcvt = nullptr;	// nothing to do

	mov	DWORD PTR _out$[ebp+60], 0

; 787  : 		else

	jmp	SHORT $LN41@main
$LN40@main:

; 788  : 			{	// set up for nontrivial codecvt facet
; 789  : 			_Pcvt = _STD addressof(_Newcvt);
; 790  : 			_Mysb::_Init();	// reset any buffering

	lea	ecx, DWORD PTR _out$[ebp+4]
	mov	DWORD PTR _out$[ebp+60], esi
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
$LN41@main:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xlocale

; 408  : 		{	// destroy the object

	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 409  : 		if (_Ptr != nullptr)

	mov	ecx, DWORD PTR $T3[ebp+4]
	test	ecx, ecx
	je	SHORT $LN48@main

; 410  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	eax, eax
	je	SHORT $LN48@main
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN48@main:

; 411  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 1267 : 			_Myios::clear();	// added with C++11

	lea	ecx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	push	0
	push	0
	mov	eax, DWORD PTR [eax+4]
	add	ecx, eax
	call	DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	jmp	SHORT $LN29@main
$LN33@main:

; 1249 : 
; 1250 : 	_NODISCARD _Myfb *rdbuf() const
; 1251 : 		{	// return pointer to file buffer
; 1252 : 		return ((_Myfb *)&_Filebuffer);
; 1253 : 		}
; 1254 : 
; 1255 : 	_NODISCARD bool is_open() const
; 1256 : 		{	// test if C stream has been opened
; 1257 : 		return (_Filebuffer.is_open());
; 1258 : 		}
; 1259 : 
; 1260 : 	void open(const char *_Filename,
; 1261 : 		ios_base::openmode _Mode = ios_base::out,
; 1262 : 		int _Prot = (int)ios_base::_Openprot)
; 1263 : 		{	// open a C stream with specified mode
; 1264 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == nullptr)
; 1265 : 			_Myios::setstate(ios_base::failbit);

	mov	eax, DWORD PTR _out$[ebp]
	lea	ecx, DWORD PTR _out$[ebp]
	push	0
	push	2
	mov	eax, DWORD PTR [eax+4]
	add	ecx, eax
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN29@main:

; 280  : 		return (_Myfile != nullptr);

	cmp	DWORD PTR _out$[ebp+80], 0
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp

; 48   : 	if (out.is_open())

	je	$LN8@main
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono

; 88   : 			: _MyRep(static_cast<_Rep>(_Val))

	movss	xmm2, DWORD PTR __real@45800000
	mov	ecx, 2
	mov	DWORD PTR _N$1$[ebp], ecx
$LL4@main:
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp

; 82   : 	for (int j = 0; j < BLOCK_ELEMENTS_QUANTITY / N; j++)

	xor	edx, edx
	mov	eax, 32					; 00000020H
	div	ecx
	xor	esi, esi
	mov	edx, eax
	mov	DWORD PTR tv814[ebp], edx
	test	edx, edx
	jle	$LN152@main
$LL74@main:

; 83   : 	{
; 84   : 		for (i = 0; i < N - 1; i++)

	lea	eax, DWORD PTR [ecx-1]
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN76@main
	mov	edx, DWORD PTR _N$1$[ebp]
	mov	ecx, esi
	dec	edx
	mov	edi, eax
	npad	11
$LL77@main:
	movd	xmm0, ecx
	add	ecx, 4096				; 00001000H

; 85   : 		{
; 86   : 			t.a = i * OFFSET + j;

	cvtdq2ps xmm0, xmm0

; 87   : 			arr[(int)t.a].a = t.a + OFFSET;

	cvttss2si eax, xmm0
	movaps	xmm1, xmm0
	addss	xmm1, xmm2
	shl	eax, 6
	movss	DWORD PTR ?arr@@3PAUELEMENT@@A[eax], xmm1
	sub	edx, 1
	jne	SHORT $LL77@main
	mov	ecx, DWORD PTR _N$1$[ebp]
	mov	edx, DWORD PTR tv814[ebp]
$LN76@main:

; 88   : 		}
; 89   : 		t.a = i * OFFSET + j;

	shl	edi, 12					; 0000000cH

; 90   : 		if (j == BLOCK_ELEMENTS_QUANTITY / N - 1)

	lea	eax, DWORD PTR [edx-1]
	add	edi, esi
	movd	xmm1, edi

; 88   : 		}
; 89   : 		t.a = i * OFFSET + j;

	cvtdq2ps xmm1, xmm1

; 90   : 		if (j == BLOCK_ELEMENTS_QUANTITY / N - 1)

	cmp	esi, eax
	jne	SHORT $LN78@main

; 91   : 		{
; 92   : 			arr[(int)t.a].a = 0;

	cvttss2si eax, xmm1
	shl	eax, 6
	mov	DWORD PTR ?arr@@3PAUELEMENT@@A[eax], 0

; 93   : 		}
; 94   : 		else

	jmp	SHORT $LN72@main
$LN78@main:

; 95   : 		{
; 96   : 			arr[(int)t.a].a = j + 1;

	lea	eax, DWORD PTR [esi+1]
	movd	xmm0, eax
	cvttss2si eax, xmm1
	cvtdq2ps xmm0, xmm0
	shl	eax, 6
	movss	DWORD PTR ?arr@@3PAUELEMENT@@A[eax], xmm0
$LN72@main:

; 82   : 	for (int j = 0; j < BLOCK_ELEMENTS_QUANTITY / N; j++)

	inc	esi
	cmp	esi, edx
	jl	$LL74@main
$LN152@main:

; 49   : 	{
; 50   : 		ELEMENT t;
; 51   : 		high_resolution_clock::time_point start, end;
; 52   : 		duration<double> time;
; 53   : 		for (int N = 2; N < MAX_N; N++)
; 54   : 		{
; 55   : 			initialize(N);
; 56   : 			start = high_resolution_clock::now();

	lea	ecx, DWORD PTR $T9[ebp]
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
	xorps	xmm0, xmm0
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _start$18[ebp], ecx
	mov	ecx, 320000000				; 1312d000H
	mov	DWORD PTR _start$18[ebp+4], eax
$LL7@main:

; 59   : 			{
; 60   : 				t = arr[(int)t.a];

	cvttss2si eax, xmm0
	shl	eax, 6
	add	eax, OFFSET ?arr@@3PAUELEMENT@@A	; arr
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR _t$17[ebp], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR _t$17[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR _t$17[ebp+32], xmm0
	movups	xmm0, XMMWORD PTR [eax+48]
	movups	XMMWORD PTR _t$17[ebp+48], xmm0
	sub	ecx, 1
	je	SHORT $LN161@main

; 57   : 			t.a = 0;
; 58   : 			for (int k = 0; k < BLOCK_ELEMENTS_QUANTITY * NUMBER_OF_REPEATS; k++)

	movss	xmm0, DWORD PTR _t$17[ebp]
	jmp	SHORT $LL7@main
$LN161@main:

; 61   : 			}
; 62   : 			end = high_resolution_clock::now();

	lea	ecx, DWORD PTR $T10[ebp]
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now

; 63   : 			time = duration_cast<duration<double>>(end - start);

	lea	edx, DWORD PTR _end$19[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _end$19[ebp+4], eax
	lea	eax, DWORD PTR _start$18[ebp]
	mov	DWORD PTR _end$19[ebp], ecx
	lea	ecx, DWORD PTR $T11[ebp]
	push	eax
	call	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
	add	esp, 4
	lea	ecx, DWORD PTR $T12[ebp]
	mov	edx, eax
	call	??$duration_cast@V?$duration@NU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,void>

; 64   : 			out << N << " " << time.count() << endl;

	mov	edi, DWORD PTR _N$1$[ebp]
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	sub	esp, 8
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _time$20[ebp], ecx
	lea	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _time$20[ebp+4], eax
	movsd	xmm0, QWORD PTR _time$20[ebp]
	movsd	QWORD PTR [esp], xmm0
	push	edi
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	edx, OFFSET ??_C@_01CLKCMJKC@?5@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 65   : 			cout << "For " << N << " time is - " << time.count() << endl;

	movsd	xmm0, QWORD PTR _time$20[ebp]
	mov	edx, OFFSET ??_C@_04EPNKNKMC@For?5@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	edi
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	edx, OFFSET ??_C@_0M@JBCCIHLB@?5time?5is?5?9?5@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	movss	xmm2, DWORD PTR __real@45800000
	mov	ecx, edi
	inc	ecx
	mov	DWORD PTR _N$1$[ebp], ecx
	cmp	ecx, 14					; 0000000eH
	jl	$LL4@main

; 66   : 		}
; 67   : 	}
; 68   : 	else

	jmp	SHORT $LN9@main
$LN8@main:

; 69   : 	{
; 70   : 		cout << "Something wrong" << endl;

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	edx, OFFSET ??_C@_0BA@DDIGICPA@Something?5wrong@
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
$LN9@main:

; 73   : 	system("pause");

	push	OFFSET ??_C@_05PDJBBECF@pause@
	call	DWORD PTR __imp__system
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 1247 : 		{	// destroy the object

	mov	eax, DWORD PTR _out$[ebp]
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp

; 73   : 	system("pause");

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 1247 : 		{	// destroy the object

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _out$[ebp+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-104]
	mov	DWORD PTR _out$[ebp+ecx-4], eax

; 1248 : 		}

	lea	ecx, DWORD PTR _out$[ebp+4]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR _out$[ebp+8]
	call	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	lea	ecx, DWORD PTR _out$[ebp+104]
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp

; 74   : 	return 0;

	xor	eax, eax

; 75   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$1:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN18@main
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR _out$[ebp+104]
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN18@main:
	ret	0
__unwindfunclet$_main$2:
	lea	ecx, DWORD PTR _out$[ebp+8]
	jmp	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$_main$4:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$_main$0:
	lea	ecx, DWORD PTR _out$[ebp]
	jmp	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__unwindfunclet$_main$5:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$_main:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$_main
	jmp	___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx

; 1247 : 		{	// destroy the object

	mov	eax, DWORD PTR [ecx]
	push	esi
	lea	esi, DWORD PTR [ecx+104]

; 1248 : 		}

	lea	ecx, DWORD PTR [esi-100]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [esi-104]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx-104]
	mov	DWORD PTR [edx+esi-108], eax
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR [esi-96]
	call	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	176					; 000000b0H
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	ret	4
?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@XZ
_TEXT	SEGMENT
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono

; 88   : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx], 0
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp

; 75   : }

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono

; 88   : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx+4], 0
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp

; 75   : }

	ret	0
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\bsuir_archive\source\repos\avp_3\avp_3\source.cpp
;	COMDAT ?initialize@@YAXH@Z
_TEXT	SEGMENT
tv326 = -8						; size = 4
tv330 = -4						; size = 4
?initialize@@YAXH@Z PROC				; initialize, COMDAT
; _N$ = ecx

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 79   : 	 ELEMENT t;
; 80   : 	 __int32 i;
; 81   : 
; 82   : 	for (int j = 0; j < BLOCK_ELEMENTS_QUANTITY / N; j++)

	mov	eax, 32					; 00000020H
	cdq
	idiv	ecx
	push	edi
	mov	edx, eax
	xor	edi, edi
	mov	DWORD PTR tv330[ebp], edx
	test	edx, edx
	jle	$LN3@initialize
	movss	xmm2, DWORD PTR __real@45800000
	lea	eax, DWORD PTR [edx-1]
	push	ebx
	push	esi
	lea	ebx, DWORD PTR [ecx-1]
	mov	DWORD PTR tv326[ebp], eax
	xorps	xmm3, xmm3
$LL4@initialize:

; 83   : 	{
; 84   : 		for (i = 0; i < N - 1; i++)

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN6@initialize
	mov	edx, ebx
	mov	ecx, edi
	mov	esi, edx
$LL7@initialize:
	movd	xmm0, ecx
	add	ecx, 4096				; 00001000H

; 85   : 		{
; 86   : 			t.a = i * OFFSET + j;

	cvtdq2ps xmm0, xmm0

; 87   : 			arr[(int)t.a].a = t.a + OFFSET;

	cvttss2si eax, xmm0
	movaps	xmm1, xmm0
	addss	xmm1, xmm2
	shl	eax, 6
	movss	DWORD PTR ?arr@@3PAUELEMENT@@A[eax], xmm1
	sub	edx, 1
	jne	SHORT $LL7@initialize
	mov	edx, DWORD PTR tv330[ebp]
	mov	eax, DWORD PTR tv326[ebp]
$LN6@initialize:

; 88   : 		}
; 89   : 		t.a = i * OFFSET + j;

	shl	esi, 12					; 0000000cH
	add	esi, edi
	movd	xmm1, esi
	cvtdq2ps xmm1, xmm1

; 90   : 		if (j == BLOCK_ELEMENTS_QUANTITY / N - 1)

	cmp	edi, eax
	jne	SHORT $LN8@initialize

; 91   : 		{
; 92   : 			arr[(int)t.a].a = 0;

	movaps	xmm0, xmm3

; 93   : 		}
; 94   : 		else

	jmp	SHORT $LN2@initialize
$LN8@initialize:

; 95   : 		{
; 96   : 			arr[(int)t.a].a = j + 1;

	lea	eax, DWORD PTR [edi+1]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
$LN2@initialize:

; 79   : 	 ELEMENT t;
; 80   : 	 __int32 i;
; 81   : 
; 82   : 	for (int j = 0; j < BLOCK_ELEMENTS_QUANTITY / N; j++)

	cvttss2si eax, xmm1
	inc	edi
	shl	eax, 6
	movss	DWORD PTR ?arr@@3PAUELEMENT@@A[eax], xmm0
	lea	eax, DWORD PTR [edx-1]
	cmp	edi, edx
	jl	SHORT $LL4@initialize
	pop	esi
	pop	ebx
$LN3@initialize:
	pop	edi

; 97   : 		}
; 98   : 		
; 99   : 	}
; 100  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?initialize@@YAXH@Z ENDP				; initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
;	COMDAT ?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ
_TEXT	SEGMENT
?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ PROC ; std::chrono::duration<double,std::ratio<1,1> >::count, COMDAT
; _this$ = ecx

; 104  : 		return (_MyRep);

	movsd	xmm0, QWORD PTR [ecx]

; 105  : 		}

	ret	0
?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ENDP ; std::chrono::duration<double,std::ratio<1,1> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; _this$ = ecx

; 211  : 		{	// construct from a duration

	push	ebp
	mov	ebp, esp

; 210  : 		: _MyDur(_Other)

	mov	edx, DWORD PTR __Other$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 212  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
;	COMDAT ?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ
_TEXT	SEGMENT
?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::zero, COMDAT
; ___$ReturnUdt$ = ecx

; 88   : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx], 0

; 177  : 		return (duration(duration_values<_Rep>::zero()));

	mov	eax, ecx

; 88   : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx+4], 0

; 178  : 		}

	ret	0
?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::zero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2459 : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN43@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN42@basic_stri

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN39@basic_stri

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN42@basic_stri:

; 207  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN43@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3995 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 506  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 2461 : 		}

	ret	0
$LN39@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN60@basic_stri:
	int	3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3976 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 2144 : 		}

	mov	eax, ecx

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 506  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 2144 : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z
_TEXT	SEGMENT
$T2 = -36						; size = 8
__Nr$7 = -28						; size = 4
__Pn$8 = -24						; size = 4
__Pb$9 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Filename$dead$ = 8					; size = 4
__Mode$dead$ = 12					; size = 4
__Prot$dead$ = 16					; size = 4
?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 1263 : 		{	// open a C stream with specified mode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 288  : 		if (_Myfile != nullptr || (_File = _Fiopen(_Filename, _Mode, _Prot)) == nullptr)

	cmp	DWORD PTR [edi+80], 0
	jne	$LN39@open
	push	64					; 00000040H
	push	2
	push	OFFSET ??_C@_0CE@HIODEGAO@D?3?2Java?2CacheAssociativity?2file@
	call	DWORD PTR __imp_?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	test	ebx, ebx
	je	$LN39@open

; 720  : 		_Mysb::_Init();	// initialize stream buffer base object

	lea	ecx, DWORD PTR [edi+4]
	mov	BYTE PTR [edi+76], 1
	mov	BYTE PTR [edi+65], 0
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 728  : 			::_get_stream_buffer_pointers(

	lea	eax, DWORD PTR __Nr$7[ebp]
	mov	DWORD PTR __Pb$9[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pn$8[ebp]
	mov	DWORD PTR __Pn$8[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pb$9[ebp]
	mov	DWORD PTR __Nr$7[ebp], 0
	push	eax
	push	ebx
	call	DWORD PTR __imp___get_stream_buffer_pointers
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 330  : 		_IGfirst = _Gf;

	mov	eax, DWORD PTR __Pb$9[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 292  : 		_Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	lea	ecx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 330  : 		_IGfirst = _Gf;

	mov	DWORD PTR [edi+16], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 728  : 			::_get_stream_buffer_pointers(

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 331  : 		_IPfirst = _Pf;

	mov	DWORD PTR [edi+20], eax

; 332  : 		_IGnext = _Gn;

	mov	eax, DWORD PTR __Pn$8[ebp]
	mov	DWORD PTR [edi+32], eax

; 333  : 		_IPnext = _Pn;

	mov	DWORD PTR [edi+36], eax

; 334  : 		_IGcount = _Gc;

	mov	eax, DWORD PTR __Nr$7[ebp]
	mov	DWORD PTR [edi+48], eax

; 335  : 		_IPcount = _Pc;

	mov	DWORD PTR [edi+52], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 739  : 		_State = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [edi+68], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [edi+72], eax

; 292  : 		_Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	lea	eax, DWORD PTR $T2[ebp]
	push	eax

; 738  : 		_Myfile = _File;

	mov	DWORD PTR [edi+80], ebx

; 740  : 		_Pcvt = nullptr;	// pointer to codecvt facet

	mov	DWORD PTR [edi+60], 0

; 292  : 		_Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	call	DWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
	mov	ebx, eax

; 785  : 		if (_Newcvt.always_noconv())

	mov	ecx, ebx
	call	DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN22@open

; 786  : 			_Pcvt = nullptr;	// nothing to do

	mov	DWORD PTR [edi+60], 0

; 787  : 		else

	jmp	SHORT $LN23@open
$LN22@open:

; 788  : 			{	// set up for nontrivial codecvt facet
; 789  : 			_Pcvt = _STD addressof(_Newcvt);
; 790  : 			_Mysb::_Init();	// reset any buffering

	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [edi+60], ebx
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
$LN23@open:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xlocale

; 408  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 409  : 		if (_Ptr != nullptr)

	mov	ecx, DWORD PTR $T2[ebp+4]
	test	ecx, ecx
	je	SHORT $LN36@open

; 410  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN36@open
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN36@open:

; 411  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 1267 : 			_Myios::clear();	// added with C++11

	mov	eax, DWORD PTR [edi]
	push	0
	push	0
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edi
	call	DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	jmp	SHORT $LN3@open
$LN39@open:

; 1264 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == nullptr)
; 1265 : 			_Myios::setstate(ios_base::failbit);

	mov	eax, DWORD PTR [edi]
	push	0
	push	2
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edi
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
$LN3@open:

; 1268 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::open
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?is_open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?is_open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::is_open, COMDAT
; _this$ = ecx

; 280  : 		return (_Myfile != nullptr);

	cmp	DWORD PTR [ecx+80], 0
	setne	al

; 1257 : 		return (_Filebuffer.is_open());
; 1258 : 		}

	ret	0
?is_open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::is_open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1247 : 		{	// destroy the object

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi-104]

; 1248 : 		}

	lea	ecx, DWORD PTR [esi-100]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [esi-104]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx-104]
	mov	DWORD PTR [edx+esi-108], eax
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR [esi-96]
	pop	esi
	jmp	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$GSCopy$ = -20					; size = 4
$T1 = -16						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_$initVBases$dead$ = 8					; size = 4
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1079 : 		{	// construct unopened

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
	mov	DWORD PTR _this$GSCopy$[ebp], edi
	lea	ecx, DWORD PTR [edi+104]
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR [edi], OFFSET ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
	call	DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
	push	0
	push	0
	lea	esi, DWORD PTR [edi+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	esi
	mov	ecx, edi
	mov	DWORD PTR $T1[ebp], 1
	call	DWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+eax], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _this$[ebp], esi
	lea	eax, DWORD PTR [ecx-104]
	mov	DWORD PTR [ecx+edi-4], eax

; 166  : 		: _Mysb()

	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 720  : 		_Mysb::_Init();	// initialize stream buffer base object

	mov	ecx, esi

; 167  : 		{	// construct from pointer to C stream

	mov	DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 717  : 		_Closef = _Which == _Openfl;

	mov	BYTE PTR [esi+72], 0

; 718  : 		_Wrotesome = false;

	mov	BYTE PTR [esi+61], 0

; 719  : 
; 720  : 		_Mysb::_Init();	// initialize stream buffer base object

	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 721  : 
; 722  : 		if (_File != nullptr && sizeof (_Elem) == 1)
; 723  : 			{	// point inside C stream with [first, first + count) buffer
; 724  : 			_Elem **_Pb = nullptr;
; 725  : 			_Elem **_Pn = nullptr;
; 726  : 			int *_Nr = nullptr;
; 727  : 
; 728  : 			::_get_stream_buffer_pointers(
; 729  : 				_File,
; 730  : 				reinterpret_cast<char***>(&_Pb),
; 731  : 				reinterpret_cast<char***>(&_Pn),
; 732  : 				&_Nr);
; 733  : 			int *_Nw = _Nr;
; 734  : 
; 735  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 736  : 			}
; 737  : 
; 738  : 		_Myfile = _File;
; 739  : 		_State = _Stinit;

	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 1080 : 		}

	mov	eax, edi

; 739  : 		_State = _Stinit;

	mov	DWORD PTR [esi+64], ecx
	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi+68], ecx

; 740  : 		_Pcvt = nullptr;	// pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0

; 1080 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN5@basic_ofst
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	add	ecx, 104				; 00000068H
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN5@basic_ofst:
	ret	0
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	add	ecx, 8
	jmp	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
__Loc$ = 8						; size = 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 709  : 		{	// set locale to argument (capture nontrivial codecvt facet)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 710  : 		_Initcvt(_STD use_facet<_Cvt>(_Loc));

	mov	ecx, DWORD PTR __Loc$[ebp]
	push	edi
	call	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
	mov	edi, eax

; 785  : 		if (_Newcvt.always_noconv())

	mov	ecx, edi
	call	DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN4@imbue
	pop	edi

; 786  : 			_Pcvt = nullptr;	// nothing to do

	mov	DWORD PTR [esi+56], 0

; 711  : 		}

	pop	esi
	pop	ebp
	ret	4
$LN4@imbue:

; 790  : 			_Mysb::_Init();	// reset any buffering

	mov	ecx, esi
	mov	DWORD PTR [esi+56], edi
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
	pop	edi

; 711  : 		}

	pop	esi
	pop	ebp
	ret	4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 702  : 		{	// synchronize C stream with external file

	push	esi
	mov	esi, ecx

; 703  : 		return (_Myfile == nullptr

	cmp	DWORD PTR [esi+76], 0
	je	SHORT $LN3@sync
	mov	eax, DWORD PTR [esi]
	push	-1
	call	DWORD PTR [eax+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 531  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 703  : 		return (_Myfile == nullptr

	je	SHORT $LN3@sync
	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp__fflush
	add	esp, 4
	test	eax, eax
	jns	SHORT $LN3@sync
	or	eax, -1
	pop	esi

; 704  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 705  : 			|| 0 <= _CSTD fflush(_Myfile) ? 0 : -1);
; 706  : 		}

	ret	0
$LN3@sync:

; 703  : 		return (_Myfile == nullptr

	xor	eax, eax
	pop	esi

; 704  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 705  : 			|| 0 <= _CSTD fflush(_Myfile) ? 0 : -1);
; 706  : 		}

	ret	0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z
_TEXT	SEGMENT
__Nr$1 = -16						; size = 4
__Pn$2 = -12						; size = 4
__Pb$3 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Buffer$ = 8						; size = 4
__Count$ = 12						; size = 8
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 689  : 		{	// offer _Buffer to C stream

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	esi
	mov	esi, ecx
	push	edi

; 690  : 		if (_Myfile == nullptr || _CSTD setvbuf(_Myfile, (char *)_Buffer,

	mov	edi, DWORD PTR [esi+76]
	test	edi, edi
	je	$LN4@setbuf
	mov	ecx, DWORD PTR __Count$[ebp]
	test	edx, edx
	jne	SHORT $LN6@setbuf
	mov	eax, ecx
	or	eax, DWORD PTR __Count$[ebp+4]
	jne	SHORT $LN6@setbuf
	mov	eax, 4
	jmp	SHORT $LN7@setbuf
$LN6@setbuf:
	xor	eax, eax
$LN7@setbuf:
	push	ecx
	push	eax
	push	edx
	push	edi
	call	DWORD PTR __imp__setvbuf
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN4@setbuf

; 691  : 			_Buffer == nullptr && _Count == 0 ? _IONBF : _IOFBF,
; 692  : 			(size_t)_Count * sizeof (_Elem)) != 0)
; 693  : 			return (nullptr);	// failed
; 694  : 		else
; 695  : 			{	// new buffer, reinitialize pointers
; 696  : 			_Init(_Myfile, _Openfl);

	mov	edi, DWORD PTR [esi+76]

; 720  : 		_Mysb::_Init();	// initialize stream buffer base object

	mov	ecx, esi
	mov	BYTE PTR [esi+72], 1
	mov	BYTE PTR [esi+61], al
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 721  : 
; 722  : 		if (_File != nullptr && sizeof (_Elem) == 1)

	test	edi, edi
	je	SHORT $LN9@setbuf

; 728  : 			::_get_stream_buffer_pointers(

	lea	eax, DWORD PTR __Nr$1[ebp]
	mov	DWORD PTR __Pb$3[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pn$2[ebp]
	mov	DWORD PTR __Pn$2[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pb$3[ebp]
	mov	DWORD PTR __Nr$1[ebp], 0
	push	eax
	push	edi
	call	DWORD PTR __imp___get_stream_buffer_pointers
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 330  : 		_IGfirst = _Gf;

	mov	eax, DWORD PTR __Pb$3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 728  : 			::_get_stream_buffer_pointers(

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 334  : 		_IGcount = _Gc;

	mov	ecx, DWORD PTR __Nr$1[ebp]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Pn$2[ebp]
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+44], ecx

; 335  : 		_IPcount = _Pc;

	mov	DWORD PTR [esi+48], ecx
$LN9@setbuf:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 739  : 		_State = _Stinit;

	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 697  : 			return (this);

	mov	eax, esi

; 738  : 		_Myfile = _File;

	mov	DWORD PTR [esi+76], edi

; 739  : 		_State = _Stinit;

	mov	DWORD PTR [esi+64], ecx
	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	pop	edi
	mov	DWORD PTR [esi+68], ecx

; 740  : 		_Pcvt = nullptr;	// pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0

; 698  : 			}
; 699  : 		}

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN4@setbuf:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	eax, eax
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
__Off$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Pos$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 675  : 		{	// change position to _Pos

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+20], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 55   : 		return (_Myoff + _Fpos);

	mov	edx, DWORD PTR __Pos$[ebp]
	add	edx, DWORD PTR __Pos$[ebp+8]
	mov	eax, DWORD PTR __Pos$[ebp+4]
	adc	eax, DWORD PTR __Pos$[ebp+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 675  : 		{	// change position to _Pos

	push	ebx
	push	esi
	mov	esi, ecx

; 676  : 		off_type _Off = static_cast<off_type>(_Pos);

	mov	DWORD PTR __Off$[esp+28], edx
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR __Off$[esp+36], eax

; 677  : 
; 678  : 		if (_Myfile == nullptr || !_Endwrite() || _CSTD fsetpos(_Myfile, &_Off) != 0)

	cmp	DWORD PTR [esi+76], 0
	je	SHORT $LN3@seekpos
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	test	al, al
	je	SHORT $LN3@seekpos
	lea	eax, DWORD PTR __Off$[esp+32]
	push	eax
	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp__fsetpos
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@seekpos

; 683  : 		_State = _Pos.state();

	mov	eax, DWORD PTR __Pos$[ebp+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	ebx, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 683  : 		_State = _Pos.state();

	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR __Pos$[ebp+20]
	mov	DWORD PTR [esi+68], eax

; 804  : 		if (_Mysb::eback() == &_Mychar)

	lea	eax, DWORD PTR [esi+60]
	cmp	DWORD PTR [ebx], eax
	jne	SHORT $LN12@seekpos

; 805  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [esi+84]
	mov	ecx, DWORD PTR [esi+80]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 253  : 		*_IGcount = (int)(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [ebx], ecx
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edx
$LN12@seekpos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 685  : 		return (pos_type(_State, _Off));	// return new position

	mov	edx, DWORD PTR [esi+64]
	mov	esi, DWORD PTR [esi+68]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 37   : 		: _Myoff(_Fileposition), _Fpos(0), _Mystate(_State)

	mov	ecx, DWORD PTR __Off$[esp+32]
	mov	DWORD PTR [edi], ecx
	mov	ecx, DWORD PTR __Off$[esp+36]
	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], edx
	mov	DWORD PTR [edi+20], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 685  : 		return (pos_type(_State, _Off));	// return new position

	jmp	SHORT $LN20@seekpos
$LN3@seekpos:
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 32   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

	mov	DWORD PTR [edi], -1
	mov	DWORD PTR [edi+4], -1
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	movq	QWORD PTR [edi+16], xmm0
$LN20@seekpos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 686  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+32]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
__Off$2$ = -20						; size = 4
__Fileposition$ = -16					; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 652  : 		{	// change position by _Off

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+20], eax
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 225  : 		return (*_IGnext);

	mov	eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 657  : 			&& _Pcvt == nullptr)	// not converting

	lea	ecx, DWORD PTR [esi+60]
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN21@seekoff
	cmp	DWORD PTR __Way$[ebp], 1
	jne	SHORT $LN21@seekoff
	cmp	DWORD PTR [esi+56], 0
	jne	SHORT $LN21@seekoff

; 658  : 			{
; 659  : 			_Off -= static_cast<off_type>(sizeof(_Elem));	// back up over _Elem bytes

	mov	ebx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Off$[ebp+4]
	add	ebx, -1
	adc	eax, -1
	jmp	SHORT $LN23@seekoff
$LN21@seekoff:

; 657  : 			&& _Pcvt == nullptr)	// not converting

	mov	eax, DWORD PTR __Off$[ebp+4]
	mov	ebx, DWORD PTR __Off$[ebp]
$LN23@seekoff:

; 660  : 			}
; 661  : 
; 662  : 		if (_Myfile == nullptr || !_Endwrite()
; 663  : 			|| ((_Off != 0 || _Way != ios_base::cur)
; 664  : 				&& _CSTD _fseeki64(_Myfile, _Off, _Way) != 0)
; 665  : 			|| _CSTD fgetpos(_Myfile, &_Fileposition) != 0)

	cmp	DWORD PTR [esi+76], 0
	mov	DWORD PTR __Off$2$[esp+32], eax
	je	$LN4@seekoff
	mov	ecx, esi
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	test	al, al
	je	$LN4@seekoff
	mov	ecx, DWORD PTR __Off$2$[esp+32]
	mov	eax, ebx
	or	eax, ecx
	mov	eax, DWORD PTR __Way$[ebp]
	jne	SHORT $LN6@seekoff
	cmp	eax, 1
	je	SHORT $LN5@seekoff
$LN6@seekoff:
	push	eax
	push	ecx
	push	ebx
	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp___fseeki64
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN4@seekoff
$LN5@seekoff:
	lea	eax, DWORD PTR __Fileposition$[esp+32]
	push	eax
	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp__fgetpos
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@seekoff
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 804  : 		if (_Mysb::eback() == &_Mychar)

	lea	ecx, DWORD PTR [esi+60]
	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN13@seekoff

; 805  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [esi+84]
	mov	ecx, DWORD PTR [esi+80]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 253  : 		*_IGcount = (int)(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edx
$LN13@seekoff:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 671  : 		return (pos_type(_State, _Fileposition));	// return new position

	mov	edx, DWORD PTR [esi+64]
	mov	esi, DWORD PTR [esi+68]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 37   : 		: _Myoff(_Fileposition), _Fpos(0), _Mystate(_State)

	mov	ecx, DWORD PTR __Fileposition$[esp+32]
	mov	DWORD PTR [edi], ecx
	mov	ecx, DWORD PTR __Fileposition$[esp+36]
	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], edx
	mov	DWORD PTR [edi+20], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 671  : 		return (pos_type(_State, _Fileposition));	// return new position

	jmp	SHORT $LN24@seekoff
$LN4@seekoff:
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 32   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

	mov	DWORD PTR [edi], -1
	mov	DWORD PTR [edi+4], -1
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	movq	QWORD PTR [edi+16], xmm0
$LN24@seekoff:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 672  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+32]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
_TEXT	SEGMENT
__Off$1$ = -20						; size = 4
__Size$2$ = -16						; size = 4
tv258 = -12						; size = 4
__Start_count$1$ = -8					; size = 4
__Start_count$2$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsputn, COMDAT
; _this$ = ecx

; 612  : 		{	// put _Count characters to stream

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 20					; 00000014H
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 613  : 		if _CONSTEXPR_IF (sizeof(_Elem) == 1)
; 614  : 			{
; 615  : 			if (_Pcvt)

	cmp	DWORD PTR [ebx+56], 0
	je	SHORT $LN4@xsputn

; 616  : 				{	// if we need a nontrivial codecvt transform, do the default expensive thing
; 617  : 				return (_Mysb::xsputn(_Ptr, _Count));

	push	DWORD PTR __Count$[ebp+4]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	DWORD PTR __imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z

; 641  : 			}
; 642  : 		else
; 643  : 			{	// non-chars always get element-by-element processing
; 644  : 			return (_Mysb::xsputn(_Ptr, _Count));
; 645  : 			}
; 646  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN4@xsputn:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 312  : 		return (*_IPnext != nullptr ? *_IPcount : 0);

	mov	eax, DWORD PTR [ebx+32]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 620  : 			const streamsize _Start_count = _Count;

	mov	esi, DWORD PTR __Count$[ebp]
	mov	edi, DWORD PTR __Count$[ebp+4]
	mov	DWORD PTR __Start_count$1$[esp+32], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 312  : 		return (*_IPnext != nullptr ? *_IPcount : 0);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 620  : 			const streamsize _Start_count = _Count;

	mov	DWORD PTR __Start_count$2$[esp+32], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 312  : 		return (*_IPnext != nullptr ? *_IPcount : 0);

	mov	DWORD PTR tv258[esp+32], eax
	test	eax, eax
	je	SHORT $LN11@xsputn
	mov	eax, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@xsputn
$LN11@xsputn:
	xor	eax, eax
$LN12@xsputn:
	cdq
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 621  : 			streamsize _Size = _Mysb::_Pnavail();

	mov	DWORD PTR __Off$1$[esp+32], eax
	mov	ecx, edx
	mov	DWORD PTR __Size$2$[esp+32], ecx

; 622  : 			if (0 < _Count && 0 < _Size)

	test	edi, edi
	jl	SHORT $LN7@xsputn
	jg	SHORT $LN19@xsputn
	test	esi, esi
	je	SHORT $LN7@xsputn
$LN19@xsputn:
	test	ecx, ecx
	jl	SHORT $LN23@xsputn
	jg	SHORT $LN20@xsputn
	test	eax, eax
	je	SHORT $LN23@xsputn
$LN20@xsputn:

; 623  : 				{	// copy to write buffer
; 624  : 				if (_Count < _Size)

	cmp	edi, ecx
	jg	SHORT $LN6@xsputn
	jl	SHORT $LN21@xsputn
	cmp	esi, eax
	jae	SHORT $LN6@xsputn
$LN21@xsputn:

; 625  : 					{
; 626  : 					_Size = _Count;

	mov	eax, esi
	mov	DWORD PTR __Off$1$[esp+32], esi
	mov	DWORD PTR __Size$2$[esp+32], edi
$LN6@xsputn:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	eax
	push	DWORD PTR __Ptr$[ebp]
	push	DWORD PTR tv258[esp+40]
	call	_memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 630  : 				_Ptr += _Size;

	mov	ecx, DWORD PTR __Off$1$[esp+44]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 630  : 				_Ptr += _Size;

	mov	edx, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 286  : 		*_IPcount -= _Off;

	mov	eax, DWORD PTR [ebx+48]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 630  : 				_Ptr += _Size;

	add	edx, ecx

; 631  : 				_Count -= _Size;

	sub	esi, ecx
	sbb	edi, DWORD PTR __Size$2$[esp+32]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 286  : 		*_IPcount -= _Off;

	sub	DWORD PTR [eax], ecx

; 287  : 		*_IPnext += _Off;

	mov	eax, DWORD PTR [ebx+32]
	add	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 622  : 			if (0 < _Count && 0 < _Size)

	jmp	SHORT $LN5@xsputn
$LN23@xsputn:
	mov	edx, DWORD PTR __Ptr$[ebp]
$LN5@xsputn:

; 632  : 				_Mysb::pbump(static_cast<int>(_Size));
; 633  : 				}
; 634  : 
; 635  : 			if (0 < _Count && _Myfile)

	test	edi, edi
	jl	SHORT $LN7@xsputn
	jg	SHORT $LN22@xsputn
	test	esi, esi
	je	SHORT $LN7@xsputn
$LN22@xsputn:
	mov	eax, DWORD PTR [ebx+76]
	test	eax, eax
	je	SHORT $LN7@xsputn

; 636  : 				{	// open C stream, attempt write
; 637  : 				_Count -= _CSTD fwrite(_Ptr, sizeof(_Elem), static_cast<size_t>(_Count), _Myfile);

	push	eax
	push	esi
	push	1
	push	edx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	sub	esi, eax
	sbb	edi, 0
$LN7@xsputn:

; 638  : 				}
; 639  : 
; 640  : 			return (_Start_count - _Count);

	mov	eax, DWORD PTR __Start_count$1$[esp+32]
	mov	edx, DWORD PTR __Start_count$2$[esp+32]
	sub	eax, esi
	sbb	edx, edi

; 641  : 			}
; 642  : 		else
; 643  : 			{	// non-chars always get element-by-element processing
; 644  : 			return (_Mysb::xsputn(_Ptr, _Count));
; 645  : 			}
; 646  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
_TEXT	SEGMENT
__Off$1$ = -20						; size = 4
__Ptr$1$ = -20						; size = 4
__Size$2$ = -16						; size = 4
tv253 = -12						; size = 4
__Start_count$1$ = -8					; size = 4
__Start_count$2$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn, COMDAT
; _this$ = ecx

; 574  : 		{	// get _Count characters from stream

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 575  : 		if _CONSTEXPR_IF (sizeof(_Elem) == 1)
; 576  : 			{
; 577  : 			if (_Pcvt)

	cmp	DWORD PTR [edi+56], 0
	je	SHORT $LN4@xsgetn

; 578  : 				{	// if we need a nontrivial codecvt transform, do the default expensive thing
; 579  : 				return (_Mysb::xsgetn(_Ptr, _Count));

	push	DWORD PTR __Count$[ebp+4]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	DWORD PTR __imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z

; 604  : 			}
; 605  : 		else
; 606  : 			{	// non-chars always get element-by-element processing
; 607  : 			return (_Mysb::xsgetn(_Ptr, _Count));
; 608  : 			}
; 609  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN4@xsgetn:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 281  : 		return (*_IGnext != nullptr ? *_IGcount : 0);

	mov	eax, DWORD PTR [edi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 582  : 			const streamsize _Start_count = _Count;

	mov	esi, DWORD PTR __Count$[ebp]
	mov	ebx, DWORD PTR __Count$[ebp+4]
	mov	DWORD PTR __Start_count$1$[esp+32], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 281  : 		return (*_IGnext != nullptr ? *_IGcount : 0);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 582  : 			const streamsize _Start_count = _Count;

	mov	DWORD PTR __Start_count$2$[esp+32], ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 281  : 		return (*_IGnext != nullptr ? *_IGcount : 0);

	mov	DWORD PTR tv253[esp+32], eax
	test	eax, eax
	je	SHORT $LN11@xsgetn
	mov	eax, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN12@xsgetn
$LN11@xsgetn:
	xor	eax, eax
$LN12@xsgetn:
	cdq
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 583  : 			streamsize _Size = _Mysb::_Gnavail();

	mov	DWORD PTR __Off$1$[esp+32], eax
	mov	ecx, edx
	mov	DWORD PTR __Size$2$[esp+32], ecx

; 584  : 			if (0 < _Count && 0 < _Size)

	test	ebx, ebx
	jl	$LN7@xsgetn
	jg	SHORT $LN19@xsgetn
	test	esi, esi
	je	$LN7@xsgetn
$LN19@xsgetn:
	test	ecx, ecx
	jl	SHORT $LN23@xsgetn
	jg	SHORT $LN20@xsgetn
	test	eax, eax
	je	SHORT $LN23@xsgetn
$LN20@xsgetn:

; 585  : 				{	// copy from get area
; 586  : 				if (_Count < _Size)

	cmp	ebx, ecx
	jg	SHORT $LN6@xsgetn
	jl	SHORT $LN21@xsgetn
	cmp	esi, eax
	jae	SHORT $LN6@xsgetn
$LN21@xsgetn:

; 587  : 					{
; 588  : 					_Size = _Count;

	mov	eax, esi
	mov	DWORD PTR __Off$1$[esp+32], esi
	mov	DWORD PTR __Size$2$[esp+32], ebx
$LN6@xsgetn:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	eax
	push	DWORD PTR tv253[esp+36]
	push	DWORD PTR __Ptr$[ebp]
	call	_memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 592  : 				_Ptr += _Size;

	mov	ecx, DWORD PTR __Off$1$[esp+44]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 592  : 				_Ptr += _Size;

	mov	edx, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 245  : 		*_IGcount -= _Off;

	mov	eax, DWORD PTR [edi+44]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 592  : 				_Ptr += _Size;

	add	edx, ecx

; 593  : 				_Count -= _Size;

	sub	esi, ecx
	mov	DWORD PTR __Ptr$1$[esp+32], edx
	sbb	ebx, DWORD PTR __Size$2$[esp+32]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 245  : 		*_IGcount -= _Off;

	sub	DWORD PTR [eax], ecx

; 246  : 		*_IGnext += _Off;

	mov	eax, DWORD PTR [edi+28]
	add	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 584  : 			if (0 < _Count && 0 < _Size)

	jmp	SHORT $LN5@xsgetn
$LN23@xsgetn:
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Ptr$1$[esp+32], eax
$LN5@xsgetn:

; 594  : 				_Mysb::gbump(static_cast<int>(_Size));
; 595  : 				}
; 596  : 
; 597  : 			if (0 < _Count && _Myfile)

	test	ebx, ebx
	jl	SHORT $LN7@xsgetn
	jg	SHORT $LN22@xsgetn
	test	esi, esi
	je	SHORT $LN7@xsgetn
$LN22@xsgetn:
	cmp	DWORD PTR [edi+76], 0
	je	SHORT $LN7@xsgetn

; 598  : 				{	// open C stream, attempt read
; 599  : 				_Reset_back();	// revert from _Mychar buffer

	mov	ecx, edi
	call	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 600  : 				_Count -= _CSTD fread(_Ptr, sizeof(_Elem), static_cast<size_t>(_Count), _Myfile);

	push	DWORD PTR [edi+76]
	push	esi
	push	1
	push	DWORD PTR __Ptr$1$[esp+44]
	call	DWORD PTR __imp__fread
	add	esp, 16					; 00000010H
	sub	esi, eax
	sbb	ebx, 0
$LN7@xsgetn:

; 601  : 				}
; 602  : 
; 603  : 			return (_Start_count - _Count);

	mov	eax, DWORD PTR __Start_count$1$[esp+32]
	mov	edx, DWORD PTR __Start_count$2$[esp+32]
	sub	eax, esi

; 604  : 			}
; 605  : 		else
; 606  : 			{	// non-chars always get element-by-element processing
; 607  : 			return (_Mysb::xsgetn(_Ptr, _Count));
; 608  : 			}
; 609  : 		}

	pop	edi
	pop	esi
	sbb	edx, ebx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
$T22 = -64						; size = 1
__Meta$1$ = -60						; size = 4
__Dest$77 = -56						; size = 4
__Src$78 = -52						; size = 4
__Ch$ = -48						; size = 1
__Str$ = -44						; size = 24
__Ch$79 = -17						; size = 1
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 508  : 		{	// get an element from stream, point past it

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 225  : 		return (*_IGnext);

	mov	eax, DWORD PTR [ebx+28]
	mov	ecx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 509  : 		if (_Mysb::gptr() != nullptr && _Mysb::gptr() < _Mysb::egptr())

	test	ecx, ecx
	je	SHORT $LN524@uflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 240  : 		return (*_IGnext + *_IGcount);

	mov	edx, DWORD PTR [ebx+44]
	mov	esi, DWORD PTR [edx]
	lea	eax, DWORD PTR [esi+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 509  : 		if (_Mysb::gptr() != nullptr && _Mysb::gptr() < _Mysb::egptr())

	cmp	ecx, eax
	jae	SHORT $LN524@uflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 269  : 		--*_IGcount;

	lea	eax, DWORD PTR [esi-1]
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ebx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 526  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 511  : 			return (_Traits::to_int_type(*_Mysb::_Gninc()));	// return buffered

	jmp	$LN498@uflow
$LN524@uflow:

; 512  : 			}
; 513  : 
; 514  : 		if (_Myfile == nullptr)

	cmp	DWORD PTR [ebx+76], 0
	jne	SHORT $LN10@uflow
$LN18@uflow:

; 567  : 				}
; 568  : 			}
; 569  : 		}

	or	eax, -1
	jmp	$LN498@uflow
$LN10@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	esi, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 804  : 		if (_Mysb::eback() == &_Mychar)

	lea	eax, DWORD PTR [ebx+60]
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN37@uflow

; 805  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [ebx+84]
	mov	ecx, DWORD PTR [ebx+80]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 253  : 		*_IGcount = (int)(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [esi], ecx
	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [ebx+44]
	mov	DWORD PTR [eax], edx
$LN37@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 520  : 		if (_Pcvt == nullptr)

	cmp	DWORD PTR [ebx+56], 0
	jne	SHORT $LN11@uflow

; 61   : 	if ((_Meta = _CSTD fgetc(_File)) == EOF)

	push	DWORD PTR [ebx+76]
	call	DWORD PTR __imp__fgetc
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN18@uflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 526  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, al

; 527  : 		}

	jmp	$LN498@uflow
$LN11@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3976 : 		_My_data._Mysize = 0;

	mov	DWORD PTR __Str$[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str$[ebp+20], 15		; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 506  : 		_Left = _Right;

	mov	BYTE PTR __Str$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 527  : 		string _Str;

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 532  : 			int _Meta = _CSTD fgetc(_Myfile);

	push	DWORD PTR [ebx+76]
	call	DWORD PTR __imp__fgetc
	add	esp, 4
	mov	DWORD PTR __Meta$1$[ebp], eax

; 533  : 
; 534  : 			if (_Meta == EOF)

	cmp	eax, -1
	je	$LN513@uflow
	lea	edi, DWORD PTR [ebx+64]
	npad	8
$LL2@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3229 : 		const size_type _Old_size = _My_data._Mysize;

	mov	ecx, DWORD PTR __Str$[ebp+16]
	mov	edx, DWORD PTR __Str$[ebp+20]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 539  : 			_Str.push_back(static_cast<char>(_Meta));	// append byte and convert

	mov	BYTE PTR __Ch$[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3229 : 		const size_type _Old_size = _My_data._Mysize;

	cmp	ecx, edx

; 3230 : 		if (_Old_size < _My_data._Myres)

	jae	SHORT $LN134@uflow

; 3232 : 			_My_data._Mysize = _Old_size + 1;

	lea	eax, DWORD PTR [ecx+1]

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 506  : 		_Left = _Right;

	mov	edx, DWORD PTR __Meta$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3232 : 			_My_data._Mysize = _Old_size + 1;

	mov	DWORD PTR __Str$[ebp+16], eax

; 1803 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Str$[ebp]

; 1804 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 506  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], dl
	mov	BYTE PTR [eax+ecx+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3236 : 			return;

	jmp	SHORT $LN133@uflow
$LN134@uflow:

; 3237 : 			}
; 3238 : 
; 3239 : 		_Reallocate_grow_by(1,

	push	DWORD PTR __Ch$[ebp]
	mov	BYTE PTR $T22[ebp], 0
	push	DWORD PTR $T22[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Str$[ebp]
	call	??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN133@uflow:

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 543  : 			switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1, _Dest))

	lea	eax, DWORD PTR __Dest$77[ebp]
	mov	ecx, DWORD PTR [ebx+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

	lea	esi, DWORD PTR __Str$[ebp]

; 1815 : 		if (_Large_string_engaged())

	cmovae	esi, DWORD PTR __Str$[ebp]

; 1814 : 		const value_type * _Result = _Bx._Buf;

	lea	edx, DWORD PTR __Str$[ebp]

; 1815 : 		if (_Large_string_engaged())

	cmovae	edx, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 543  : 			switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1, _Dest))

	push	eax
	lea	eax, DWORD PTR __Ch$79[ebp+1]
	push	eax
	lea	eax, DWORD PTR __Ch$79[ebp]
	push	eax
	lea	eax, DWORD PTR __Src$78[ebp]
	push	eax
	mov	eax, DWORD PTR __Str$[ebp+16]
	add	eax, esi
	push	eax
	push	edx
	push	edi
	call	DWORD PTR __imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z
	test	eax, eax
	js	SHORT $LN513@uflow
	cmp	eax, 1
	jg	$LN514@uflow

; 544  : 				{	// test result of converting one element
; 545  : 				case codecvt_base::partial:
; 546  : 				case codecvt_base::ok:
; 547  : 					if (_Dest != &_Ch)

	lea	eax, DWORD PTR __Ch$79[ebp]
	cmp	DWORD PTR __Dest$77[ebp], eax
	lea	eax, DWORD PTR __Str$[ebp]
	jne	SHORT $LN515@uflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H

; 1803 : 		value_type * _Result = _Bx._Buf;

	lea	edx, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 558  : 					_Str.erase(0, static_cast<size_t>(_Src - _Str.data()));	// partial, discard used input

	mov	edi, DWORD PTR __Src$78[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 1815 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 558  : 					_Str.erase(0, static_cast<size_t>(_Src - _Str.data()));	// partial, discard used input

	sub	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	mov	eax, DWORD PTR __Str$[ebp+16]
	cmp	eax, edi
	cmovb	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H

; 1804 : 		if (_Large_string_engaged())

	cmovae	edx, DWORD PTR __Str$[ebp]

; 2848 : 		const size_type _New_size = _Old_size - _Count;

	sub	eax, edi

; 2849 : 		_My_data._Mysize = _New_size;

	mov	DWORD PTR __Str$[ebp+16], eax

; 2850 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 2850 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

	lea	eax, DWORD PTR [edx+edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	eax
	push	edx
	call	_memmove
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 532  : 			int _Meta = _CSTD fgetc(_Myfile);

	push	DWORD PTR [ebx+76]
	call	DWORD PTR __imp__fgetc
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Meta$1$[ebp], eax

; 533  : 
; 534  : 			if (_Meta == EOF)

	lea	edi, DWORD PTR [ebx+64]
	cmp	eax, -1
	jne	$LL2@uflow
$LN513@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

	or	esi, -1
$LN390@uflow:
	mov	edx, DWORD PTR __Str$[ebp+20]
	cmp	edx, 16					; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN434@uflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN433@uflow

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN433@uflow
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN515@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 549  : 						auto _Nleft = _Str.data() + _Str.size() - _Src;

	mov	esi, DWORD PTR __Str$[ebp+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 1815 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 549  : 						auto _Nleft = _Str.data() + _Str.size() - _Src;

	mov	ecx, DWORD PTR __Src$78[ebp]
	sub	esi, ecx
	add	esi, eax

; 550  : 						while (0 < _Nleft)

	test	esi, esi
	jle	SHORT $LN527@uflow
	mov	edi, DWORD PTR __imp__ungetc
	npad	1
$LL7@uflow:

; 551  : 							{
; 552  : 							_CSTD ungetc(_Src[--_Nleft], _Myfile);

	push	DWORD PTR [ebx+76]
	movsx	eax, BYTE PTR [esi+ecx-1]
	dec	esi
	push	eax
	call	edi
	add	esp, 8
	test	esi, esi
	jle	SHORT $LN527@uflow

; 550  : 						while (0 < _Nleft)

	mov	ecx, DWORD PTR __Src$78[ebp]
	jmp	SHORT $LL7@uflow
$LN527@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 526  : 		return (static_cast<unsigned char>(_Ch));

	movzx	esi, BYTE PTR __Ch$79[ebp]
	jmp	SHORT $LN390@uflow
$LN514@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 543  : 			switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1, _Dest))

	cmp	eax, 3
	jne	SHORT $LN513@uflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H

; 1803 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Str$[ebp]

; 1804 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 563  : 					return (static_cast<int_type>(_Str.front()));

	movsx	esi, BYTE PTR [eax]
	jmp	SHORT $LN390@uflow
$LN433@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 207  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN434@uflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 566  : 					return (_Traits::eof());	// conversion failed

	mov	eax, esi
$LN498@uflow:

; 567  : 				}
; 568  : 			}
; 569  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN530@uflow:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ$0:
	lea	ecx, DWORD PTR __Str$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 493  : 		{	// get an element from stream, but don't point past it

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 225  : 		return (*_IGnext);

	mov	eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 496  : 			&& _Mysb::gptr() < _Mysb::egptr())

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@underflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 240  : 		return (*_IGnext + *_IGcount);

	mov	eax, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [eax]
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 496  : 			&& _Mysb::gptr() < _Mysb::egptr())

	cmp	ecx, eax
	jae	SHORT $LN2@underflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 526  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [ecx]
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 505  : 		}

	ret	0
$LN2@underflow:

; 498  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	edi
	call	DWORD PTR [eax+28]
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 531  : 		return (_Left == _Right);

	cmp	edi, -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 498  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

	jne	SHORT $LN4@underflow

; 499  : 			return (_Meta);	// uflow failed, return EOF

	pop	edi
	or	eax, eax
	pop	esi

; 505  : 		}

	ret	0
$LN4@underflow:

; 500  : 		else
; 501  : 			{	// get a char, don't point past it
; 502  : 			pbackfail(_Meta);

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	edi
	call	DWORD PTR [eax+16]

; 503  : 			return (_Meta);

	mov	eax, edi
	pop	edi
	pop	esi

; 505  : 		}

	ret	0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 468  : 		{	// put an element back to stream

	push	ebp
	mov	ebp, esp
	push	ebx

; 471  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

	mov	ebx, DWORD PTR __Meta$[ebp]
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 225  : 		return (*_IGnext);

	mov	eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 471  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@pbackfail
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 471  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

	cmp	DWORD PTR [eax], ecx
	jae	SHORT $LN2@pbackfail
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 531  : 		return (_Left == _Right);

	cmp	ebx, -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 471  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

	je	SHORT $LN4@pbackfail
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 526  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [ecx-1]

; 531  : 		return (_Left == _Right);

	cmp	eax, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 471  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

	jne	SHORT $LN2@pbackfail
$LN4@pbackfail:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 263  : 		++*_IGcount;

	mov	eax, DWORD PTR [esi+44]
	inc	DWORD PTR [eax]

; 264  : 		return (--*_IGnext);

	mov	eax, DWORD PTR [esi+28]
	dec	DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 476  : 			return (_Traits::not_eof(_Meta));

	xor	eax, eax
	cmp	ebx, -1
	cmove	ebx, eax
$LN70@pbackfail:

; 487  : 			}
; 488  : 		else
; 489  : 			return (_Traits::eof());	// nowhere to put back
; 490  : 	}

	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
$LN2@pbackfail:

; 478  : 		else if (_Myfile == nullptr || _Traits::eq_int_type(_Traits::eof(), _Meta))

	mov	eax, DWORD PTR [esi+76]
	test	eax, eax
	je	SHORT $LN7@pbackfail
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 531  : 		return (_Left == _Right);

	cmp	ebx, -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 478  : 		else if (_Myfile == nullptr || _Traits::eq_int_type(_Traits::eof(), _Meta))

	je	SHORT $LN7@pbackfail

; 480  : 		else if (_Pcvt == nullptr && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

	cmp	DWORD PTR [esi+56], 0
	jne	SHORT $LN68@pbackfail

; 129  : 	return (_CSTD ungetc((unsigned char)_Byte, _File) != EOF);

	push	eax
	movzx	ecx, bl
	push	ecx
	call	DWORD PTR __imp__ungetc
	add	esp, 8
	cmp	eax, -1

; 480  : 		else if (_Pcvt == nullptr && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

	jne	SHORT $LN70@pbackfail
$LN68@pbackfail:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 225  : 		return (*_IGnext);

	mov	ecx, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 482  : 		else if (_Mysb::gptr() != &_Mychar)

	lea	edx, DWORD PTR [esi+60]
	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN7@pbackfail

; 484  : 			_Mychar = _Traits::to_char_type(_Meta);

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	edi, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 484  : 			_Mychar = _Traits::to_char_type(_Meta);

	mov	BYTE PTR [edx], bl

; 810  : 		if (_Mysb::eback() != &_Mychar)

	mov	eax, DWORD PTR [edi]
	cmp	eax, edx
	je	SHORT $LN69@pbackfail

; 811  : 			{	// save current get buffer
; 812  : 			_Set_eback = _Mysb::eback();

	mov	DWORD PTR [esi+80], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 240  : 		return (*_IGnext + *_IGcount);

	mov	eax, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 813  : 			_Set_egptr = _Mysb::egptr();

	mov	DWORD PTR [esi+84], eax
$LN69@pbackfail:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 251  : 		*_IGfirst = _First;

	mov	DWORD PTR [edi], edx

; 253  : 		*_IGcount = (int)(_Last - _Next);

	mov	ecx, esi
	mov	eax, DWORD PTR [esi+28]
	sub	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 486  : 			return (_Meta);

	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 253  : 		*_IGcount = (int)(_Last - _Next);

	add	ecx, 61					; 0000003dH
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR [esi+44]
	pop	esi
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 486  : 			return (_Meta);

	mov	eax, ebx

; 487  : 			}
; 488  : 		else
; 489  : 			return (_Traits::eof());	// nowhere to put back
; 490  : 	}

	pop	ebx
	pop	ebp
	ret	4
$LN7@pbackfail:
	pop	esi

; 479  : 			return (_Traits::eof());	// no open C stream or EOF, fail

	or	eax, -1

; 487  : 			}
; 488  : 		else
; 489  : 			return (_Traits::eof());	// nowhere to put back
; 490  : 	}

	pop	ebx
	pop	ebp
	ret	4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
__Src$ = -48						; size = 4
__Dest$ = -44						; size = 4
__Ch$ = -37						; size = 1
__Str$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
__Meta$ = 8						; size = 4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 408  : 		{	// put an element to stream

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 531  : 		return (_Left == _Right);

	mov	ebx, DWORD PTR __Meta$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 408  : 		{	// put an element to stream

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 531  : 		return (_Left == _Right);

	cmp	ebx, -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 409  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	jne	SHORT $LN4@overflow

; 410  : 			{
; 411  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

	pop	esi
	xor	eax, eax

; 460  : 
; 461  : 			default:
; 462  : 				return (_Traits::eof());	// conversion failed
; 463  : 			}
; 464  : 		}

	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 235  : 		return (*_IPnext);

	mov	eax, DWORD PTR [esi+32]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 414  : 		if (_Mysb::pptr() != nullptr && _Mysb::pptr() < _Mysb::epptr())

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN5@overflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 258  : 		return (*_IPnext + *_IPcount);

	mov	edx, DWORD PTR [esi+48]
	mov	edx, DWORD PTR [edx]
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 414  : 		if (_Mysb::pptr() != nullptr && _Mysb::pptr() < _Mysb::epptr())

	cmp	eax, edx
	jae	SHORT $LN5@overflow

; 415  : 			{	// room in buffer, store it
; 416  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	call	DWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
	pop	esi
	mov	BYTE PTR [eax], bl

; 417  : 			return (_Meta);

	mov	eax, ebx

; 460  : 
; 461  : 			default:
; 462  : 				return (_Traits::eof());	// conversion failed
; 463  : 			}
; 464  : 		}

	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN5@overflow:

; 418  : 			}
; 419  : 
; 420  : 		if (_Myfile == nullptr)

	cmp	DWORD PTR [esi+76], 0
	push	edi
	je	$LN12@overflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	edi, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 804  : 		if (_Mysb::eback() == &_Mychar)

	lea	eax, DWORD PTR [esi+60]
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN43@overflow

; 805  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [esi+84]
	mov	ecx, DWORD PTR [esi+80]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 253  : 		*_IGcount = (int)(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [edi], ecx
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edx
$LN43@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 426  : 		if (_Pcvt == nullptr)

	mov	ecx, DWORD PTR [esi+56]
	test	ecx, ecx
	jne	SHORT $LN7@overflow

; 105  : 	return (_CSTD fputc(_Byte, _File) != EOF);

	movsx	eax, bl

; 427  : 			{	// no codecvt facet, put as is
; 428  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof());

	jmp	SHORT $LN69@overflow
$LN7@overflow:

; 437  : 		switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf, _Dest))

	lea	eax, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 521  : 		return (static_cast<char>(_Meta));

	mov	BYTE PTR __Ch$[ebp], bl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 437  : 		switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf, _Dest))

	push	eax
	lea	eax, DWORD PTR __Str$[ebp+32]
	push	eax
	lea	eax, DWORD PTR __Str$[ebp]
	push	eax
	lea	eax, DWORD PTR __Src$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ch$[ebp+1]
	push	eax
	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+64]
	push	eax
	call	DWORD PTR __imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PBD1AAPBDPAD3AAPAD@Z
	test	eax, eax
	js	SHORT $LN12@overflow
	cmp	eax, 1
	jle	SHORT $LN8@overflow
	cmp	eax, 3
	jne	SHORT $LN12@overflow

; 105  : 	return (_CSTD fputc(_Byte, _File) != EOF);

	movsx	eax, BYTE PTR __Ch$[ebp]
$LN69@overflow:
	push	DWORD PTR [esi+76]
	push	eax
	call	DWORD PTR __imp__fputc
	add	esp, 8

; 452  : 					}
; 453  : 
; 454  : 				return (_Traits::eof());	// conversion failed
; 455  : 				}
; 456  : 
; 457  : 			case codecvt_base::noconv:
; 458  : 				// no conversion, put as is
; 459  : 				return (_Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof());

	or	ecx, -1

; 105  : 	return (_CSTD fputc(_Byte, _File) != EOF);

	cmp	eax, ecx

; 452  : 					}
; 453  : 
; 454  : 				return (_Traits::eof());	// conversion failed
; 455  : 				}
; 456  : 
; 457  : 			case codecvt_base::noconv:
; 458  : 				// no conversion, put as is
; 459  : 				return (_Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof());

	cmovne	ecx, ebx
	pop	edi
	pop	esi
	mov	eax, ecx

; 460  : 
; 461  : 			default:
; 462  : 				return (_Traits::eof());	// conversion failed
; 463  : 			}
; 464  : 		}

	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN8@overflow:

; 438  : 			{	// test result of converting one element
; 439  : 			case codecvt_base::partial:
; 440  : 			case codecvt_base::ok:
; 441  : 				{	// converted something, try to put it out
; 442  : 				const auto _Count = static_cast<size_t>(_Dest - _Str);

	mov	edi, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR __Str$[ebp]
	sub	edi, eax

; 443  : 				if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile)))

	je	SHORT $LN9@overflow
	push	DWORD PTR [esi+76]
	push	edi
	push	1
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	edi, eax
	jne	SHORT $LN12@overflow
$LN9@overflow:

; 444  : 					{
; 445  : 					return (_Traits::eof());	// write failed
; 446  : 					}
; 447  : 
; 448  : 				_Wrotesome = true;	// write succeeded
; 449  : 				if (_Src != &_Ch)

	lea	eax, DWORD PTR __Ch$[ebp]
	mov	BYTE PTR [esi+61], 1
	cmp	DWORD PTR __Src$[ebp], eax
	je	SHORT $LN12@overflow

; 450  : 					{
; 451  : 					return (_Meta);	// converted whole element

	pop	edi
	pop	esi
	mov	eax, ebx

; 460  : 
; 461  : 			default:
; 462  : 				return (_Traits::eof());	// conversion failed
; 463  : 			}
; 464  : 		}

	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN12@overflow:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	or	eax, -1
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 402  : 		if (_Myfile)

	mov	eax, DWORD PTR [ecx+76]
	test	eax, eax
	je	SHORT $LN2@Unlock

; 403  : 			_CSTD _unlock_file(_Myfile);

	push	eax
	call	DWORD PTR __imp___unlock_file
	pop	ecx
$LN2@Unlock:

; 404  : 		}

	ret	0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 396  : 		if (_Myfile)

	mov	eax, DWORD PTR [ecx+76]
	test	eax, eax
	je	SHORT $LN2@Lock

; 397  : 			_CSTD _lock_file(_Myfile);

	push	eax
	call	DWORD PTR __imp___lock_file
	pop	ecx
$LN2@Lock:

; 398  : 		}

	ret	0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 172  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 173  : 		if (_Myfile != nullptr)

	cmp	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	je	SHORT $LN6@basic_file
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	edi, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 804  : 		if (_Mysb::eback() == &_Mychar)

	lea	eax, DWORD PTR [esi+60]
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN6@basic_file

; 805  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [esi+84]
	mov	ecx, DWORD PTR [esi+80]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 253  : 		*_IGcount = (int)(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [edi], ecx
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edx
$LN6@basic_file:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 175  : 		if (_Closef)

	cmp	BYTE PTR [esi+72], 0
	je	SHORT $LN3@basic_file

; 381  : 		if (_Myfile == nullptr)

	cmp	DWORD PTR [esi+76], 0
	je	SHORT $LN16@basic_file

; 382  : 			_Ans = nullptr;
; 383  : 		else
; 384  : 			{	// put any homing sequence and close file
; 385  : 			if (!_Endwrite())

	mov	ecx, esi
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 386  : 				_Ans = nullptr;
; 387  : 			if (_CSTD fclose(_Myfile) != 0)

	push	DWORD PTR [esi+76]
	call	DWORD PTR __imp__fclose
	add	esp, 4
$LN16@basic_file:

; 720  : 		_Mysb::_Init();	// initialize stream buffer base object

	mov	ecx, esi
	mov	BYTE PTR [esi+72], 0
	mov	BYTE PTR [esi+61], 0
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 721  : 
; 722  : 		if (_File != nullptr && sizeof (_Elem) == 1)
; 723  : 			{	// point inside C stream with [first, first + count) buffer
; 724  : 			_Elem **_Pb = nullptr;
; 725  : 			_Elem **_Pn = nullptr;
; 726  : 			int *_Nr = nullptr;
; 727  : 
; 728  : 			::_get_stream_buffer_pointers(
; 729  : 				_File,
; 730  : 				reinterpret_cast<char***>(&_Pb),
; 731  : 				reinterpret_cast<char***>(&_Pn),
; 732  : 				&_Nr);
; 733  : 			int *_Nw = _Nr;
; 734  : 
; 735  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 736  : 			}
; 737  : 
; 738  : 		_Myfile = _File;
; 739  : 		_State = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi+68], eax

; 740  : 		_Pcvt = nullptr;	// pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0
$LN3@basic_file:

; 176  : 			close();
; 177  : 		}

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 1247 : 		{	// destroy the object

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi-104]
	push	edi
	lea	edi, DWORD PTR [esi-104]

; 1248 : 		}

	lea	ecx, DWORD PTR [esi-100]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi-104], OFFSET ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx-104]
	mov	DWORD PTR [edx+esi-108], eax
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	ecx, DWORD PTR [esi-96]
	call	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	176					; 000000b0H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
;	COMDAT ?zero@?$duration_values@_J@chrono@std@@SA_JXZ
_TEXT	SEGMENT
?zero@?$duration_values@_J@chrono@std@@SA_JXZ PROC	; std::chrono::duration_values<__int64>::zero, COMDAT

; 37   : 		return (_Rep(0));

	xor	eax, eax
	xor	edx, edx

; 38   : 		}

	ret	0
?zero@?$duration_values@_J@chrono@std@@SA_JXZ ENDP	; std::chrono::duration_values<__int64>::zero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 153  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 154  : 			}

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 135  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 136  :  #if _HAS_EXCEPTIONS
; 137  : 			if (!_STD uncaught_exception())	// TRANSITION, OS#15518458

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN2@sentry

; 138  : 				{
; 139  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 105  : 			{	// destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 106  : 			if (_Myostr.rdbuf() != nullptr)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN5@sentry

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN5@sentry:

; 140  : 				}
; 141  :  #else /* _HAS_EXCEPTIONS */
; 142  : 			this->_Myostr._Osfx();
; 143  :  #endif /* _HAS_EXCEPTIONS */
; 144  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 121  : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
	mov	esi, DWORD PTR __Ostr$[ebp]

; 98   : 			: _Myostr(_Ostr)

	mov	DWORD PTR [edi], esi

; 100  : 			if (_Myostr.rdbuf() != nullptr)

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios

; 87   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 100  : 			if (_Myostr.rdbuf() != nullptr)

	test	ecx, ecx
	je	SHORT $LN6@sentry

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [esi]
$LN6@sentry:

; 102  : 			}
; 103  : 
; 104  : 		__CLR_OR_THIS_CALL ~_Sentry_base() noexcept
; 105  : 			{	// destroy after unlocking
; 106  : 			if (_Myostr.rdbuf() != nullptr)
; 107  : 				_Myostr.rdbuf()->_Unlock();
; 108  : 			}
; 109  : 
; 110  : 		basic_ostream& _Myostr;	// the output stream, for _Unlock call at destruction
; 111  : 
; 112  : 		_Sentry_base& operator=(const _Sentry_base&) = delete;
; 113  : 		};
; 114  : 
; 115  : 	class sentry
; 116  : 		: public _Sentry_base
; 117  : 		{	// stores thread lock and state of stream
; 118  : 	public:
; 119  : 		explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr)
; 120  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xiosbase

; 352  : 		return (rdstate() == ios_base::goodbit);

	mov	eax, edx

; 330  : 		return (_Mystate);

	mov	ecx, DWORD PTR [edx+4]

; 352  : 		return (rdstate() == ios_base::goodbit);

	cmp	DWORD PTR [ecx+esi+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN2@sentry
	mov	ecx, DWORD PTR [ecx+esi+60]
	test	ecx, ecx
	je	SHORT $LN2@sentry
	cmp	ecx, esi
	je	SHORT $LN2@sentry

; 123  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	mov	eax, DWORD PTR [esi]
$LN2@sentry:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xiosbase

; 352  : 		return (rdstate() == ios_base::goodbit);

	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+esi+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 124  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR [edi+4], al

; 125  : 			}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$dead$ = ecx

; 1862 : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	setae	al

; 1826 : 		}

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1814 : 		const value_type * _Result = _Bx._Buf;
; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN8@Myptr

; 1816 : 			{
; 1817 : 			_Result = _Unfancy(_Bx._Ptr);
; 1818 : 			}
; 1819 : 
; 1820 : 		return (_Result);

	mov	eax, DWORD PTR [ecx]

; 1821 : 		}

	ret	0
$LN8@Myptr:

; 1816 : 			{
; 1817 : 			_Result = _Unfancy(_Bx._Ptr);
; 1818 : 			}
; 1819 : 
; 1820 : 		return (_Result);

	mov	eax, ecx

; 1821 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1803 : 		value_type * _Result = _Bx._Buf;
; 1804 : 		if (_Large_string_engaged())

	jb	SHORT $LN8@Myptr

; 1805 : 			{
; 1806 : 			_Result = _Unfancy(_Bx._Ptr);
; 1807 : 			}
; 1808 : 
; 1809 : 		return (_Result);

	mov	eax, DWORD PTR [ecx]

; 1810 : 		}

	ret	0
$LN8@Myptr:

; 1805 : 			{
; 1806 : 			_Result = _Unfancy(_Bx._Ptr);
; 1807 : 			}
; 1808 : 
; 1809 : 		return (_Result);

	mov	eax, ecx

; 1810 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 2048 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 2049 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 2043 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 2044 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 2038 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 2039 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 2033 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 2034 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 2023 : 		_Get_data()._Orphan_all();
; 2024 : 		}

	ret	0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1784 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1911 : 		}

	mov	eax, ecx

; 1785 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1911 : 		}

	ret	0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3984 : 		{	// initialize buffer, deallocating any storage

	push	esi
	mov	esi, ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3985 : 		this->_Orphan_all();
; 3986 : 		auto& _My_data = this->_Get_data();
; 3987 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN41@Tidy_deall
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN40@Tidy_deall

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN37@Tidy_deall

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN40@Tidy_deall:

; 207  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN41@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3995 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 506  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 4000 : 		}

	ret	0
$LN37@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN46@Tidy_deall:
	int	3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 3975 : 		auto& _My_data = this->_Get_data();
; 3976 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 506  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3981 : 		}

	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$dead$ = ecx

; 3307 : 		const size_type _Alloc_max = _Alty_traits::max_size(this->_Getal());
; 3308 : 		const size_type _Storage_max = // can always store small string
; 3309 : 			_Max_value(_Alloc_max, static_cast<size_type>(this->_BUF_SIZE));
; 3310 : 		return (_Min_value(

	mov	eax, 2147483647				; 7fffffffH

; 3311 : 			static_cast<size_type>((numeric_limits<difference_type>::max)()),
; 3312 : 			_Storage_max - 1 // -1 is for null terminator and/or npos
; 3313 : 			));
; 3314 : 
; 3315 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 33   : 	return (_Left < _Right ? _Right : _Left);

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	cmovb	ecx, edx
	mov	eax, ecx

; 34   : 	}

	ret	0
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3302 : 		return (this->_Get_data()._Mysize);

	mov	eax, DWORD PTR [ecx+16]

; 3303 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN14@data

; 3285 : 		return (this->_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 3286 : 		}

	ret	0
$LN14@data:

; 3285 : 		return (this->_Get_data()._Myptr());

	mov	eax, ecx

; 3286 : 		}

	ret	0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ
_TEXT	SEGMENT
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front, COMDAT
; _this$ = ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1804 : 		if (_Large_string_engaged())

	jb	SHORT $LN30@front

; 3260 : 		return (*begin());

	mov	eax, DWORD PTR [ecx]

; 3261 : 		}

	ret	0
$LN30@front:

; 3260 : 		return (*begin());

	mov	eax, ecx

; 3261 : 		}

	ret	0
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
$T3 = -4						; size = 1
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 3227 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	push	ecx

; 3228 : 		auto& _My_data = this->_Get_data();
; 3229 : 		const size_type _Old_size = _My_data._Mysize;

	mov	edx, DWORD PTR [ecx+16]

; 3230 : 		if (_Old_size < _My_data._Myres)

	cmp	edx, DWORD PTR [ecx+20]
	jae	SHORT $LN2@push_back

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 3231 : 			{
; 3232 : 			_My_data._Mysize = _Old_size + 1;

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx+16], eax

; 1804 : 		if (_Large_string_engaged())

	jb	SHORT $LN9@push_back
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstddef

; 346  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN9@push_back:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 506  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [ecx+edx], al
	mov	BYTE PTR [ecx+edx+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3246 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@push_back:

; 3233 : 			_Elem * const _Ptr = _My_data._Myptr();
; 3234 : 			_Traits::assign(_Ptr[_Old_size], _Ch);
; 3235 : 			_Traits::assign(_Ptr[_Old_size + 1], _Elem());
; 3236 : 			return;
; 3237 : 			}
; 3238 : 
; 3239 : 		_Reallocate_grow_by(1,

	push	DWORD PTR __Ch$[ebp]
	mov	BYTE PTR $T3[ebp], 0
	push	DWORD PTR $T3[ebp]
	push	ecx
	call	??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>

; 3246 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ch$ = 20						; size = 1
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z PROC ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator(), COMDAT
; _this$dead$ = ecx

; 3241 : 				const _Elem _Ch) {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Old_ptr$[ebp]
	push	esi
	mov	esi, DWORD PTR __Old_size$[ebp]
	push	edi
	mov	edi, DWORD PTR __New_ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	esi
	push	eax
	push	edi
	call	_memcpy

; 506  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH

; 506  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], al
	mov	BYTE PTR [esi+edi+1], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3245 : 			}, _Ch);

	pop	ebp
	ret	16					; 00000010H
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z ENDP ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 2841 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Count$[ebp]
	push	esi
	mov	esi, ecx

; 1803 : 		value_type * _Result = _Bx._Buf;

	mov	edx, esi

; 1830 : 		if (_Mysize < _Off)

	mov	ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	cmp	ecx, eax
	cmovb	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1804 : 		if (_Large_string_engaged())

	jb	SHORT $LN16@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstddef

; 346  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
$LN16@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 2848 : 		const size_type _New_size = _Old_size - _Count;

	sub	ecx, eax

; 2849 : 		_My_data._Mysize = _New_size;

	mov	DWORD PTR [esi+16], ecx

; 2850 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 2850 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

	lea	ecx, DWORD PTR [eax+edx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	ecx
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 2851 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2852 : 		}

	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT
; _this$ = ecx

; 809  : 		{	// set up putback area

	mov	edx, ecx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	edi, DWORD PTR [edx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 810  : 		if (_Mysb::eback() != &_Mychar)

	lea	esi, DWORD PTR [edx+60]
	mov	eax, DWORD PTR [edi]
	cmp	eax, esi
	je	SHORT $LN13@Set_back
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 240  : 		return (*_IGnext + *_IGcount);

	mov	ecx, DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 812  : 			_Set_eback = _Mysb::eback();

	mov	DWORD PTR [edx+80], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 240  : 		return (*_IGnext + *_IGcount);

	mov	eax, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 813  : 			_Set_egptr = _Mysb::egptr();

	mov	DWORD PTR [edx+84], eax
$LN13@Set_back:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 251  : 		*_IGfirst = _First;

	mov	DWORD PTR [edi], esi

; 252  : 		*_IGnext = _Next;
; 253  : 		*_IGcount = (int)(_Last - _Next);

	mov	ecx, edx
	mov	eax, DWORD PTR [edx+28]
	sub	ecx, esi
	add	ecx, 61					; 0000003dH
	pop	edi
	mov	DWORD PTR [eax], esi
	mov	eax, DWORD PTR [edx+44]
	pop	esi
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 816  : 		}

	ret	0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; _this$ = ecx

; 803  : 		{	// restore buffer after putback

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	edi, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 804  : 		if (_Mysb::eback() == &_Mychar)

	lea	eax, DWORD PTR [ecx+60]
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN2@Reset_back

; 805  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	edx, DWORD PTR [ecx+80]
	push	esi
	mov	esi, DWORD PTR [ecx+84]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 251  : 		*_IGfirst = _First;

	mov	DWORD PTR [edi], edx

; 252  : 		*_IGnext = _Next;
; 253  : 		*_IGcount = (int)(_Last - _Next);

	sub	esi, edx
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax], esi
	pop	esi
$LN2@Reset_back:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 806  : 		}

	ret	0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
__Newcvt$ = 8						; size = 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT
; _this$ = ecx

; 784  : 		{	// initialize codecvt pointer

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 785  : 		if (_Newcvt.always_noconv())

	mov	edi, DWORD PTR __Newcvt$[ebp]
	mov	esi, ecx
	mov	ecx, edi
	call	DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN2@Initcvt

; 786  : 			_Pcvt = nullptr;	// nothing to do

	pop	edi
	mov	DWORD PTR [esi+56], 0

; 791  : 			}
; 792  : 		}

	pop	esi
	pop	ebp
	ret	4
$LN2@Initcvt:

; 787  : 		else
; 788  : 			{	// set up for nontrivial codecvt facet
; 789  : 			_Pcvt = _STD addressof(_Newcvt);
; 790  : 			_Mysb::_Init();	// reset any buffering

	mov	ecx, esi
	mov	DWORD PTR [esi+56], edi
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
	pop	edi

; 791  : 			}
; 792  : 		}

	pop	esi
	pop	ebp
	ret	4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXABV?$codecvt@DDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
_TEXT	SEGMENT
__Dest$ = -40						; size = 4
__Str$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT
; _this$ = ecx

; 744  : 		{	// put shift to initial conversion state, as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, ecx
	push	edi

; 745  : 		if (_Pcvt == nullptr || !_Wrotesome)

	cmp	DWORD PTR [esi+56], 0
	je	$LN5@Endwrite
	cmp	BYTE PTR [esi+61], 0
	je	SHORT $LN5@Endwrite

; 751  : 		if (_Traits::eq_int_type(_Traits::eof(), overflow()))

	mov	eax, DWORD PTR [esi]
	push	-1
	call	DWORD PTR [eax+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 531  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 751  : 		if (_Traits::eq_int_type(_Traits::eof(), overflow()))

	je	SHORT $LN19@Endwrite

; 752  : 			{
; 753  : 			return (false);
; 754  : 			}
; 755  : 
; 756  : 		constexpr size_t _Codecvt_temp_buf = 32;
; 757  : 		char _Str[_Codecvt_temp_buf];
; 758  : 		char * _Dest;
; 759  : 		switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest))

	mov	ecx, DWORD PTR [esi+56]
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	eax, DWORD PTR __Str$[ebp+32]
	push	eax
	lea	eax, DWORD PTR __Str$[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+64]
	push	eax
	call	DWORD PTR __imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QBEHAAU_Mbstatet@@PAD1AAPAD@Z
	sub	eax, 0
	je	SHORT $LN7@Endwrite
	sub	eax, 1
	je	SHORT $LN8@Endwrite
	sub	eax, 2
	je	SHORT $LN5@Endwrite
$LN19@Endwrite:
	pop	edi

; 773  : 				}
; 774  : 
; 775  : 			case codecvt_base::noconv:
; 776  : 				return (true);	// nothing to do
; 777  : 
; 778  : 			default:
; 779  : 				return (false);	// conversion failed
; 780  : 			}
; 781  : 		}

	xor	al, al
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@Endwrite:

; 760  : 			{	// test result of homing conversion
; 761  : 			case codecvt_base::ok:
; 762  : 				_Wrotesome = false;	// homed successfully

	mov	BYTE PTR [esi+61], 0
$LN8@Endwrite:

; 763  : 
; 764  : 			case codecvt_base::partial:	// fall through
; 765  : 				{	// put any generated bytes
; 766  : 				const auto _Count = static_cast<size_t>(_Dest - _Str);

	mov	edi, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR __Str$[ebp]
	sub	edi, eax

; 767  : 				if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile)))

	je	SHORT $LN9@Endwrite
	push	DWORD PTR [esi+76]
	push	edi
	push	1
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	edi, eax
	jne	SHORT $LN19@Endwrite
$LN9@Endwrite:

; 768  : 					{
; 769  : 					return (false);	// write failed
; 770  : 					}
; 771  : 
; 772  : 				return (!_Wrotesome);

	cmp	BYTE PTR [esi+61], 0
	pop	edi
	sete	al

; 773  : 				}
; 774  : 
; 775  : 			case codecvt_base::noconv:
; 776  : 				return (true);	// nothing to do
; 777  : 
; 778  : 			default:
; 779  : 				return (false);	// conversion failed
; 780  : 			}
; 781  : 		}

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@Endwrite:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, 1
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
__Nr$1 = -16						; size = 4
__Pn$2 = -12						; size = 4
__Pb$3 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__File$ = 8						; size = 4
__Which$ = 12						; size = 4
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 714  : 		{	// initialize to C stream _File after {new, open, close}

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 715  : 		__PURE_APPDOMAIN_GLOBAL static _Myst _Stinit;	// initial state
; 716  : 
; 717  : 		_Closef = _Which == _Openfl;

	cmp	DWORD PTR __Which$[ebp], 1
	push	esi
	mov	esi, ecx
	sete	al
	push	edi
	mov	edi, DWORD PTR __File$[ebp]
	mov	BYTE PTR [esi+72], al

; 718  : 		_Wrotesome = false;

	mov	BYTE PTR [esi+61], 0

; 719  : 
; 720  : 		_Mysb::_Init();	// initialize stream buffer base object

	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 721  : 
; 722  : 		if (_File != nullptr && sizeof (_Elem) == 1)

	test	edi, edi
	je	SHORT $LN2@Init

; 728  : 			::_get_stream_buffer_pointers(

	lea	eax, DWORD PTR __Nr$1[ebp]
	mov	DWORD PTR __Pb$3[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pn$2[ebp]
	mov	DWORD PTR __Pn$2[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pb$3[ebp]
	mov	DWORD PTR __Nr$1[ebp], 0
	push	eax
	push	edi
	call	DWORD PTR __imp___get_stream_buffer_pointers
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 330  : 		_IGfirst = _Gf;

	mov	eax, DWORD PTR __Pb$3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 728  : 			::_get_stream_buffer_pointers(

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 330  : 		_IGfirst = _Gf;

	mov	DWORD PTR [esi+12], eax

; 331  : 		_IPfirst = _Pf;

	mov	DWORD PTR [esi+16], eax

; 332  : 		_IGnext = _Gn;

	mov	eax, DWORD PTR __Pn$2[ebp]
	mov	DWORD PTR [esi+28], eax

; 333  : 		_IPnext = _Pn;

	mov	DWORD PTR [esi+32], eax

; 334  : 		_IGcount = _Gc;

	mov	eax, DWORD PTR __Nr$1[ebp]
	mov	DWORD PTR [esi+44], eax

; 335  : 		_IPcount = _Pc;

	mov	DWORD PTR [esi+48], eax
$LN2@Init:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 739  : 		_State = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 740  : 		_Pcvt = nullptr;	// pointer to codecvt facet
; 741  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	DWORD PTR [esi+76], edi
	xor	ecx, ebp
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	pop	edi
	mov	DWORD PTR [esi+68], eax
	mov	DWORD PTR [esi+56], 0
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ
_TEXT	SEGMENT
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 379  : 		{	// close the C stream

	push	esi
	mov	esi, ecx
	push	edi

; 380  : 		basic_filebuf *_Ans = this;
; 381  : 		if (_Myfile == nullptr)

	cmp	DWORD PTR [esi+76], 0
	jne	SHORT $LN2@close

; 382  : 			_Ans = nullptr;

	xor	edi, edi

; 383  : 		else

	jmp	SHORT $LN5@close
$LN2@close:

; 384  : 			{	// put any homing sequence and close file
; 385  : 			if (!_Endwrite())

	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 386  : 				_Ans = nullptr;
; 387  : 			if (_CSTD fclose(_Myfile) != 0)

	push	DWORD PTR [esi+76]
	xor	ecx, ecx
	mov	edi, esi
	test	al, al
	cmove	edi, ecx
	call	DWORD PTR __imp__fclose
	xor	ecx, ecx
	add	esp, 4
	test	eax, eax
	cmovne	edi, ecx
$LN5@close:

; 720  : 		_Mysb::_Init();	// initialize stream buffer base object

	mov	ecx, esi
	mov	BYTE PTR [esi+72], 0
	mov	BYTE PTR [esi+61], 0
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 739  : 		_State = _Stinit;

	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 388  : 				_Ans = nullptr;
; 389  : 			}
; 390  : 		_Init(nullptr, _Closefl);
; 391  : 		return (_Ans);

	mov	eax, edi

; 739  : 		_State = _Stinit;

	mov	DWORD PTR [esi+64], ecx
	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4

; 388  : 				_Ans = nullptr;
; 389  : 			}
; 390  : 		_Init(nullptr, _Closefl);
; 391  : 		return (_Ans);

	pop	edi

; 738  : 		_Myfile = _File;

	mov	DWORD PTR [esi+76], 0

; 739  : 		_State = _Stinit;

	mov	DWORD PTR [esi+68], ecx

; 740  : 		_Pcvt = nullptr;	// pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0

; 388  : 				_Ans = nullptr;
; 389  : 			}
; 390  : 		_Init(nullptr, _Closefl);
; 391  : 		return (_Ans);

	pop	esi

; 392  : 		}

	ret	0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
_TEXT	SEGMENT
$T1 = -32						; size = 8
__Nr$6 = -28						; size = 4
__Pn$7 = -24						; size = 4
__Pb$8 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Filename$dead$ = 8					; size = 4
__Mode$dead$ = 12					; size = 4
__Prot$dead$ = 16					; size = 4
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 286  : 		{	// open a C stream with specified mode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 287  : 		FILE *_File;
; 288  : 		if (_Myfile != nullptr || (_File = _Fiopen(_Filename, _Mode, _Prot)) == nullptr)

	cmp	DWORD PTR [esi+76], 0
	jne	$LN3@open
	push	64					; 00000040H
	push	2
	push	OFFSET ??_C@_0CE@HIODEGAO@D?3?2Java?2CacheAssociativity?2file@
	call	DWORD PTR __imp_?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z
	mov	edi, eax
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	$LN3@open

; 720  : 		_Mysb::_Init();	// initialize stream buffer base object

	mov	ecx, esi
	mov	BYTE PTR [esi+72], 1
	mov	BYTE PTR [esi+61], 0
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 728  : 			::_get_stream_buffer_pointers(

	lea	eax, DWORD PTR __Nr$6[ebp]
	mov	DWORD PTR __Pb$8[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pn$7[ebp]
	mov	DWORD PTR __Pn$7[ebp], 0
	push	eax
	lea	eax, DWORD PTR __Pb$8[ebp]
	mov	DWORD PTR __Nr$6[ebp], 0
	push	eax
	push	edi
	call	DWORD PTR __imp___get_stream_buffer_pointers
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 330  : 		_IGfirst = _Gf;

	mov	eax, DWORD PTR __Pb$8[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 728  : 			::_get_stream_buffer_pointers(

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 330  : 		_IGfirst = _Gf;

	mov	DWORD PTR [esi+12], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 292  : 		_Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\streambuf

; 331  : 		_IPfirst = _Pf;

	mov	DWORD PTR [esi+16], eax

; 332  : 		_IGnext = _Gn;

	mov	eax, DWORD PTR __Pn$7[ebp]
	mov	DWORD PTR [esi+28], eax

; 333  : 		_IPnext = _Pn;

	mov	DWORD PTR [esi+32], eax

; 334  : 		_IGcount = _Gc;

	mov	eax, DWORD PTR __Nr$6[ebp]
	mov	DWORD PTR [esi+44], eax

; 335  : 		_IPcount = _Pc;

	mov	DWORD PTR [esi+48], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 739  : 		_State = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+68], eax

; 292  : 		_Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	lea	eax, DWORD PTR $T1[ebp]
	push	eax

; 738  : 		_Myfile = _File;

	mov	DWORD PTR [esi+76], edi

; 740  : 		_Pcvt = nullptr;	// pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0

; 292  : 		_Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	call	DWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
	mov	edi, eax

; 785  : 		if (_Newcvt.always_noconv())

	mov	ecx, edi
	call	DWORD PTR __imp_?always_noconv@codecvt_base@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN18@open

; 786  : 			_Pcvt = nullptr;	// nothing to do

	mov	DWORD PTR [esi+56], 0

; 787  : 		else

	jmp	SHORT $LN19@open
$LN18@open:

; 788  : 			{	// set up for nontrivial codecvt facet
; 789  : 			_Pcvt = _STD addressof(_Newcvt);
; 790  : 			_Mysb::_Init();	// reset any buffering

	mov	ecx, esi
	mov	DWORD PTR [esi+56], edi
	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
$LN19@open:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xlocale

; 408  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 409  : 		if (_Ptr != nullptr)

	mov	ecx, DWORD PTR $T1[ebp+4]
	test	ecx, ecx
	je	SHORT $LN32@open

; 410  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN32@open
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN32@open:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream

; 293  : 		return (this);	// open succeeded

	mov	eax, esi
	jmp	SHORT $LN1@open
$LN3@open:

; 289  : 			return (nullptr);	// open failed

	xor	eax, eax
$LN1@open:

; 294  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::is_open, COMDAT
; _this$ = ecx

; 280  : 		return (_Myfile != nullptr);

	cmp	DWORD PTR [ecx+76], 0
	setne	al

; 281  : 		}

	ret	0
?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::is_open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\fstream
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__File$dead$ = 8					; size = 4
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 167  : 		{	// construct from pointer to C stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR _this$GSCopy$[ebp], esi
	call	DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 720  : 		_Mysb::_Init();	// initialize stream buffer base object

	mov	ecx, esi

; 167  : 		{	// construct from pointer to C stream

	mov	DWORD PTR [esi], OFFSET ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 717  : 		_Closef = _Which == _Openfl;

	mov	BYTE PTR [esi+72], 0

; 718  : 		_Wrotesome = false;

	mov	BYTE PTR [esi+61], 0

; 719  : 
; 720  : 		_Mysb::_Init();	// initialize stream buffer base object

	call	DWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ

; 721  : 
; 722  : 		if (_File != nullptr && sizeof (_Elem) == 1)
; 723  : 			{	// point inside C stream with [first, first + count) buffer
; 724  : 			_Elem **_Pb = nullptr;
; 725  : 			_Elem **_Pn = nullptr;
; 726  : 			int *_Nr = nullptr;
; 727  : 
; 728  : 			::_get_stream_buffer_pointers(
; 729  : 				_File,
; 730  : 				reinterpret_cast<char***>(&_Pb),
; 731  : 				reinterpret_cast<char***>(&_Pn),
; 732  : 				&_Nr);
; 733  : 			int *_Nw = _Nr;
; 734  : 
; 735  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 736  : 			}
; 737  : 
; 738  : 		_Myfile = _File;
; 739  : 		_State = _Stinit;

	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A

; 168  : 		_Init(_File, _Newfl);
; 169  : 		}

	mov	eax, esi

; 739  : 		_State = _Stinit;

	mov	DWORD PTR [esi+64], ecx
	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
	mov	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi+68], ecx

; 740  : 		_Pcvt = nullptr;	// pointer to codecvt facet

	mov	DWORD PTR [esi+56], 0

; 168  : 		_Init(_File, _Newfl);
; 169  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z$0:
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$dead$ = ecx

; 996  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 52   : 		return (::operator new(_Bytes));

	add	esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN15@allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	pop	ebp
	ret	4
$LN15@allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@allocate:

; 188  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN7@allocate

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	pop	ebp
	ret	4
$LN7@allocate:

; 193  : 	return (nullptr);

	xor	eax, eax

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	pop	ebp
	ret	4
$LN26@allocate:
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$dead$ = ecx

; 990  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 993  : 		}

	pop	ebp
	ret	8
$LN12@deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT
; _this$ = ecx

; 53   : 			// TRANSITION, ABI: We currently always set _Fpos to 0 but older .objs containing old basic_filebuf
; 54   : 			// would set _Fpos.
; 55   : 		return (_Myoff + _Fpos);

	mov	eax, DWORD PTR [ecx+8]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+12]
	adc	edx, DWORD PTR [ecx+4]

; 56   : 		}

	ret	0
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
;	COMDAT ?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ PROC ; std::fpos<_Mbstatet>::state, COMDAT
; _this$ = ecx

; 42   : 		{	// return conversion state

	push	ebp
	mov	ebp, esp

; 43   : 		return (_Mystate);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 44   : 		}

	pop	ebp
	ret	4
?state@?$fpos@U_Mbstatet@@@std@@QBE?AU_Mbstatet@@XZ ENDP ; std::fpos<_Mbstatet>::state
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z
_TEXT	SEGMENT
__State$ = 8						; size = 8
__Fileposition$ = 16					; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z PROC	; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with conversion state and C file position

	push	ebp
	mov	ebp, esp

; 37   : 		: _Myoff(_Fileposition), _Fpos(0), _Mystate(_State)

	mov	eax, DWORD PTR __Fileposition$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Fileposition$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR __State$[ebp+4]
	mov	DWORD PTR [ecx+20], eax

; 39   : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	pop	ebp
	ret	16					; 00000010H
??0?$fpos@U_Mbstatet@@@std@@QAE@U_Mbstatet@@_J@Z ENDP	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 33   : 		{	// construct with stream offset

	xorps	xmm0, xmm0

; 32   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

	mov	DWORD PTR [ecx], -1
	mov	DWORD PTR [ecx+4], -1

; 34   : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	movq	QWORD PTR [ecx+16], xmm0
	ret	8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 105  : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 106  : 			if (_Myostr.rdbuf() != nullptr)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 108  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 99   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp

; 98   : 			: _Myostr(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]

; 99   : 			{	// lock the stream buffer, if there

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 100  : 			if (_Myostr.rdbuf() != nullptr)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 102  : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 307  : 		return (_Myval2);

	mov	eax, ecx

; 308  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 302  : 		return (_Myval2);

	mov	eax, ecx

; 303  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 297  : 		return (*this);

	mov	eax, ecx

; 298  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 292  : 		return (*this);

	mov	eax, ecx

; 293  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 1652 : 		return (const_cast<reference>(_Mybase::operator*()));

	mov	eax, DWORD PTR [ecx]

; 1653 : 		}

	ret	0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 1850 : 		{	// trims _Size to the longest it can be assuming a string at/after _Off

	push	ebp
	mov	ebp, esp

; 1851 : 		return (_Min_value(_Size, _Mysize - _Off));

	mov	ecx, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	mov	eax, DWORD PTR __Size$[ebp]
	cmp	ecx, eax
	cmovb	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 1852 : 		}

	pop	ebp
	ret	8
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$dead$ = ecx

; 1830 : 		if (_Mysize < _Off)
; 1831 : 			{
; 1832 : 			_Xran();
; 1833 : 			}
; 1834 : 		}

	ret	4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

	or	eax, -1

; 893  : 		}

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 3072 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1804 : 		if (_Large_string_engaged())

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jb	SHORT $LN24@begin
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstddef

; 346  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN24@begin:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3075 : 		}

	mov	DWORD PTR [eax], ecx
	pop	ebp
	ret	4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 1423 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1424 : 		_STL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
; 1425 : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 1426 : 		_STL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"
; 1427 : 			" invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1428 : 		const auto _Contptr = _Mycont->_Myptr();
; 1429 : 		const auto _Rawptr = _Unfancy(_Ptr);
; 1430 : 		_STL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
; 1431 : 			"cannot dereference string iterator because it is out of range (e.g. an end iterator)");
; 1432 : #endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
; 1433 : 
; 1434 : 		_Analysis_assume_(_Ptr);
; 1435 : 		return (*_Ptr);

	mov	eax, DWORD PTR [ecx]

; 1436 : 		}

	ret	0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$dead$ = 12					; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 1647 : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp

; 1416 : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 1648 : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 1846 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN3@Xran:
	int	3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$dead$ = 12					; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 1417 : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp

; 1416 : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 1418 : 		this->_Adopt(_Pstring);
; 1419 : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 24   : 	return (_Right < _Left ? _Right : _Left);

	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	cmovb	ecx, edx
	mov	eax, ecx

; 25   : 	}

	ret	0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>, COMDAT
; _this$ = ecx

; 89   : 		{	// construct from representation

	push	ebp
	mov	ebp, esp

; 88   : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 90   : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
;	COMDAT ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 652  : 	{	// add time_point to time_point

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx

; 310  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	mov	eax, DWORD PTR __Right$[ebp]

; 652  : 	{	// add time_point to time_point

	push	esi

; 310  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	sub	esi, DWORD PTR [eax]

; 88   : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx], esi

; 310  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sbb	edx, DWORD PTR [eax+4]

; 653  : 	return (_Left.time_since_epoch() - _Right.time_since_epoch());

	mov	eax, ecx

; 88   : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx+4], edx

; 654  : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
;	COMDAT ??$duration_cast@V?$duration@NU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
_TEXT	SEGMENT
??$duration_cast@V?$duration@NU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,void>, COMDAT
; ___$ReturnUdt$ = ecx
; __Dur$ = edx

; 499  : 	{	// convert duration to another duration; truncate

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	mov	eax, edx
	push	esi
	mov	esi, ecx

; 500  : 	using _CF = ratio_divide<_Period, typename _To::period>;
; 501  : 
; 502  : 	using _ToRep = typename _To::rep;
; 503  : 	using _CR = common_type_t<_ToRep, _Rep, intmax_t>;
; 504  : 
; 505  : #pragma warning(push)
; 506  : #pragma warning(disable: 6326)	// Potential comparison of a constant with another constant.
; 507  : 	return (_CF::num == 1 && _CF::den == 1

	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	call	__ltod3
	divsd	xmm0, QWORD PTR __real@41cdcd6500000000
	mov	eax, esi
	movsd	QWORD PTR [esi], xmm0

; 508  : 			? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
; 509  : 		: _CF::num != 1 && _CF::den == 1
; 510  : 			? static_cast<_To>(static_cast<_ToRep>(
; 511  : 				static_cast<_CR>(
; 512  : 					_Dur.count()) * static_cast<_CR>(_CF::num)))
; 513  : 		: _CF::num == 1 && _CF::den != 1
; 514  : 			? static_cast<_To>(static_cast<_ToRep>(
; 515  : 				static_cast<_CR>(_Dur.count())
; 516  : 					/ static_cast<_CR>(_CF::den)))
; 517  : 		: static_cast<_To>(static_cast<_ToRep>(
; 518  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 519  : 				/ static_cast<_CR>(_CF::den))));
; 520  : #pragma warning(pop)
; 521  : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$duration_cast@V?$duration@NU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -48						; size = 8
__Pad$ = -48						; size = 8
__State$ = -40						; size = 4
__Val$1$ = -36						; size = 4
$T20 = -36						; size = 1
__Count$2$ = -32					; size = 4
__Pad$1$ = -28						; size = 4
$T14 = -28						; size = 1
tv805 = -24						; size = 4
tv802 = -24						; size = 4
__Ostr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Val$ = edx

; 790  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, edx
	mov	DWORD PTR __Val$1$[ebp], eax
	mov	ebx, ecx
	mov	DWORD PTR __Ostr$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 464  : 		return (_CSTD strlen(_First));

	mov	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 793  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 464  : 		return (_CSTD strlen(_First));

	lea	esi, DWORD PTR [ecx+1]
$LL103@operator:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL103@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 795  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

	mov	edx, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 464  : 		return (_CSTD strlen(_First));

	sub	ecx, esi
	mov	DWORD PTR __Count$2$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xiosbase

; 433  : 		return (_Wide);

	mov	eax, DWORD PTR [edx+4]
	add	eax, ebx
	mov	DWORD PTR tv805[ebp], eax
	mov	edi, DWORD PTR [eax+36]
	mov	esi, DWORD PTR [eax+32]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 795  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN105@operator
	test	esi, esi
	je	SHORT $LN17@operator
	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN105@operator
	cmp	esi, ecx
	jbe	SHORT $LN17@operator
$LN105@operator:
	sub	esi, ecx
	sbb	edi, 0
	jmp	SHORT $LN118@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$[ebp], xmm0
	mov	edi, DWORD PTR __Pad$[ebp+4]
	mov	esi, DWORD PTR __Pad$[ebp]
$LN118@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios

; 87   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+56]
	mov	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 98   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Pad$1$[ebp], edi
	mov	DWORD PTR __Ok$[ebp], ebx

; 99   : 			{	// lock the stream buffer, if there
; 100  : 			if (_Myostr.rdbuf() != nullptr)

	test	eax, eax
	je	SHORT $LN37@operator

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	ecx, DWORD PTR tv805[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ebx]
	mov	ecx, edx
$LN37@operator:

; 120  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xiosbase

; 330  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+4]
	add	eax, ebx
	mov	DWORD PTR tv802[ebp], eax
	mov	eax, edx

; 352  : 		return (rdstate() == ios_base::goodbit);

	mov	ebx, DWORD PTR tv802[ebp]
	cmp	DWORD PTR [ebx+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr)

	mov	ebx, DWORD PTR __Ostr$[ebp]
	jne	SHORT $LN33@operator
	mov	ebx, DWORD PTR tv802[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios

; 75   : 		return (_Tiestr);

	mov	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr)

	cmp	DWORD PTR [ebx+60], 0
	mov	ebx, DWORD PTR __Ostr$[ebp]
	je	SHORT $LN33@operator
	mov	edi, DWORD PTR tv802[ebp]
	mov	edx, DWORD PTR [edi+60]
	mov	edi, DWORD PTR __Pad$1$[ebp]
	cmp	edx, ebx
	je	SHORT $LN33@operator

; 123  : 				_Ostr.tie()->flush();

	mov	ecx, edx
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	mov	eax, DWORD PTR [ebx]
	mov	ecx, eax
$LN33@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xiosbase

; 330  : 		return (_Mystate);

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+ebx+12]

; 352  : 		return (rdstate() == ios_base::goodbit);

	test	eax, eax
	sete	BYTE PTR __Ok$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 797  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
	test	eax, eax

; 798  : 
; 799  : 	if (!_Ok)

	je	SHORT $LN8@operator

; 800  : 		_State |= ios_base::badbit;

	mov	ecx, 4

; 801  : 	else

	jmp	$LN22@operator
$LN8@operator:

; 802  : 		{	// state okay, insert
; 803  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xiosbase

; 390  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [edx+ebx+20]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 804  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN99@operator
	npad	4
$LL4@operator:

; 805  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	edi, edi
	jl	SHORT $LN3@operator
	jg	SHORT $LN106@operator
	test	esi, esi
	je	SHORT $LN3@operator
$LN106@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios

; 108  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 806  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios

; 108  : 		return (_Fillch);

	mov	BYTE PTR $T14[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 806  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T14[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	eax, -1
	jne	SHORT $LN2@operator

; 807  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 808  : 					{	// insertion failed, quit
; 809  : 					_State |= ios_base::badbit;

	lea	ecx, DWORD PTR [eax+5]

; 810  : 					break;

	jmp	SHORT $LN6@operator
$LN2@operator:

; 805  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL4@operator
$LN3@operator:

; 814  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	mov	ecx, DWORD PTR [ebx]
$LN99@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios

; 87   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 814  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	push	0
	push	DWORD PTR __Count$2$[ebp]
	push	DWORD PTR __Val$1$[ebp]
	mov	ecx, DWORD PTR [eax+ebx+56]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	eax, DWORD PTR __Count$2$[ebp]
	jne	SHORT $LN107@operator
	test	edx, edx
	jne	SHORT $LN107@operator
$LL109@operator:

; 815  : 			_State |= ios_base::badbit;
; 816  : 
; 817  : 		if (_State == ios_base::goodbit)
; 818  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	edi, edi
	jl	SHORT $LN113@operator
	jg	SHORT $LN108@operator
	test	esi, esi
	je	SHORT $LN113@operator
$LN108@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios

; 108  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 819  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios

; 108  : 		return (_Fillch);

	mov	BYTE PTR $T20[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 819  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T20[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	eax, -1
	jne	SHORT $LN5@operator
$LN107@operator:

; 820  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 821  : 					{	// insertion failed, quit
; 822  : 					_State |= ios_base::badbit;
; 823  : 					break;
; 824  : 					}
; 825  : 		_Ostr.width(0);

	mov	ecx, 4
	jmp	SHORT $LN6@operator
$LN5@operator:

; 815  : 			_State |= ios_base::badbit;
; 816  : 
; 817  : 		if (_State == ios_base::goodbit)
; 818  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL109@operator
$LN113@operator:

; 820  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 821  : 					{	// insertion failed, quit
; 822  : 					_State |= ios_base::badbit;
; 823  : 					break;
; 824  : 					}
; 825  : 		_Ostr.width(0);

	xor	ecx, ecx
$LN6@operator:
	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xiosbase

; 439  : 		_Wide = _Newwidth;

	mov	DWORD PTR [eax+ebx+32], 0
	mov	DWORD PTR [eax+ebx+36], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
	jmp	SHORT $LN119@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 826  : 		_CATCH_IO_(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN23@operator
	ret	0
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ios
	mov	ebx, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR __State$[ebp]
$LN119@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream

; 827  : 		}
; 828  : 
; 829  : 	_Ostr.setstate(_State);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
	mov	eax, DWORD PTR [ebx]
	push	0
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 135  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 136  :  #if _HAS_EXCEPTIONS
; 137  : 			if (!_STD uncaught_exception())	// TRANSITION, OS#15518458

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN82@operator

; 138  : 				{
; 139  : 				this->_Myostr._Osfx();

	mov	ecx, esi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN82@operator:

; 105  : 			{	// destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 5

; 106  : 			if (_Myostr.rdbuf() != nullptr)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN110@operator

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN110@operator:

; 830  : 	return (_Ostr);
; 831  : 	}

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1019 : 	{	// insert newline and flush stream

	push	ebp
	mov	ebp, esp
	push	esi

; 1020 : 	_Ostr.put(_Ostr.widen('\n'));

	mov	esi, DWORD PTR __Ostr$[ebp]
	push	10					; 0000000aH
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	movzx	ecx, al
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z

; 1021 : 	_Ostr.flush();

	mov	ecx, esi
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 1022 : 	return (_Ostr);

	mov	eax, esi
	pop	esi

; 1023 : 	}

	pop	ebp
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT
; __Ptr$ = ecx

; 346  : 	return (_Ptr);

	mov	eax, ecx

; 347  : 	}

	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 12
__Psave$19 = -28					; size = 4
__Psave_guard$20 = -24					; size = 4
__Lock$21 = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,_Mbstatet> >, COMDAT
; __Loc$ = ecx

; 505  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 506  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$21[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 507  : 		const locale::facet *_Psave =
; 508  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave

; 509  : 
; 510  : 		const size_t _Id = _Facet::id;

	mov	ecx, DWORD PTR __imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
	mov	DWORD PTR __Psave$19[ebp], eax
	call	DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
	mov	edi, eax

; 436  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	mov	eax, DWORD PTR [ebx+4]
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN15@use_facet
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+edi*4]

; 437  : 			? _Ptr->_Facetvec[_Id] : nullptr;	// null if id off end
; 438  : 		if (_Facptr != nullptr || !_Ptr->_Xparent)

	test	esi, esi
	jne	SHORT $LN62@use_facet
	jmp	SHORT $LN65@use_facet
$LN15@use_facet:

; 436  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	xor	esi, esi
$LN65@use_facet:

; 437  : 			? _Ptr->_Facetvec[_Id] : nullptr;	// null if id off end
; 438  : 		if (_Facptr != nullptr || !_Ptr->_Xparent)

	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN12@use_facet

; 439  : 			return (_Facptr);	// found facet or not transparent
; 440  : 		else
; 441  : 			{	// look in current locale
; 442  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

	call	DWORD PTR __imp_?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ

; 443  : 			return (_Id < _Ptr0->_Facetcount

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN66@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN12@use_facet:

; 511  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 512  : 
; 513  : 		if (_Pf == nullptr)

	test	esi, esi
	jne	SHORT $LN62@use_facet
$LN66@use_facet:

; 514  : 			{
; 515  : 			if (_Psave != nullptr)

	mov	esi, DWORD PTR __Psave$19[ebp]
	test	esi, esi
	jne	SHORT $LN62@use_facet

; 516  : 				{
; 517  : 				_Pf = _Psave;	// lazy facet already allocated
; 518  : 				}
; 519  : 			else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	lea	eax, DWORD PTR __Psave$19[ebp]
	push	ebx
	push	eax
	call	DWORD PTR __imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN71@use_facet

; 523  :  #else /* _HAS_EXCEPTIONS */
; 524  : 				abort();	// lazy disallowed
; 525  :  #endif /* _HAS_EXCEPTIONS */
; 526  : 				}
; 527  : 			else
; 528  : 				{	// queue up lazy facet for destruction
; 529  : 				auto _Pfmod = const_cast<locale::facet *>(_Psave);

	mov	esi, DWORD PTR __Psave$19[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	DWORD PTR __Psave_guard$20[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xlocale

; 535  : 				_Facet_Register(_Pfmod);

	push	esi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 536  :  #endif /* defined(_M_CEE) */
; 537  : 
; 538  : 				_Pfmod->_Incref();

	mov	eax, DWORD PTR [esi]
	add	esp, 4
	mov	ecx, esi
	call	DWORD PTR [eax+4]

; 539  : 				_Facetptr<_Facet>::_Psave = _Psave;

	mov	esi, DWORD PTR __Psave$19[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
$LN62@use_facet:

; 540  : 				_Pf = _Psave;
; 541  : 
; 542  : 				(void) _Psave_guard.release();
; 543  : 				}
; 544  : 			}
; 545  : 
; 546  : 		return (static_cast<const _Facet&>(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$21[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	mov	eax, esi

; 547  : 	_END_LOCK()
; 548  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@use_facet:

; 520  : 				{
; 521  :  #if _HAS_EXCEPTIONS
; 522  : 				_THROW(bad_cast{});	// lazy disallowed

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0bad_cast@std@@QAE@XZ			; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	mov	eax, ecx
	push	eax
	call	__CxxThrowException@8
$LN68@use_facet:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$21[ebp]
	jmp	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__unwindfunclet$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z$1:
	lea	ecx, DWORD PTR __Psave_guard$20[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
__ehhandler$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@DDU_Mbstatet@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 1784 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 279  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 1785 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 279  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT
; __Val$ = ecx

; 330  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 331  : 	}

	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z
_TEXT	SEGMENT
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$dead$ = edx

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

	ret	0
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
tv528 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$dead$ = 8				; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>, COMDAT
; _this$ = ecx

; 3919 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx

; 3920 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3921 : 		auto& _My_data = this->_Get_data();
; 3922 : 		const size_type _Old_size = _My_data._Mysize;
; 3923 : 		if (max_size() - _Old_size < _Size_increase)

	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	push	esi
	push	edi
	mov	edx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	DWORD PTR __Old_size$1$[ebp], edx
	cmp	eax, 1
	jb	$LN127@Reallocate

; 3926 : 			}
; 3927 : 
; 3928 : 		const size_type _New_size = _Old_size + _Size_increase;
; 3929 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	esi, DWORD PTR [ebx+20]
	lea	edi, DWORD PTR [edx+1]

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	or	edi, 15					; 0000000fH

; 3926 : 			}
; 3927 : 
; 3928 : 		const size_type _New_size = _Old_size + _Size_increase;
; 3929 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], esi

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	cmp	edi, ecx

; 3870 : 		if (_Masked > _Max)

	jbe	SHORT $LN25@Reallocate

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);

	mov	edi, ecx
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;
; 3876 : 		if (_Old > _Max - _Old / 2)

	mov	eax, esi
	shr	eax, 1
	sub	ecx, eax
	cmp	esi, ecx
	jbe	SHORT $LN26@Reallocate

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3879 : 			}
; 3880 : 
; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	add	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	edi, eax
	cmovb	edi, eax
$LN24@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	xor	ecx, ecx
	mov	eax, edi
	add	eax, 1
	setb	cl
	neg	ecx
	or	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN57@Reallocate

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN103@Reallocate

; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	mov	edx, DWORD PTR __Old_size$1$[ebp]

; 103  : 		& ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN56@Reallocate
$LN57@Reallocate:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN58@Reallocate

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new

; 190  : 		return (_Traits::_Allocate(_Bytes));

	mov	edx, DWORD PTR __Old_size$1$[ebp]

; 52   : 		return (::operator new(_Bytes));

	add	esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

	mov	esi, eax
	jmp	SHORT $LN56@Reallocate
$LN58@Reallocate:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

	xor	esi, esi
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3937 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	DWORD PTR __Old$1$[ebp], 16		; 00000010H
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ebx+20], edi
	lea	edi, DWORD PTR [esi+edx]
	mov	DWORD PTR [ebx+16], eax
	mov	DWORD PTR tv528[ebp], edi
	push	edx
	jb	SHORT $LN3@Reallocate

; 3938 : 			{
; 3939 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	edi
	push	esi
	call	_memcpy

; 506  : 		_Left = _Right;

	mov	ecx, DWORD PTR tv528[ebp]

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH

; 506  : 		_Left = _Right;

	mov	al, BYTE PTR _<_Args_0>$[ebp]
	mov	BYTE PTR [ecx], al
	mov	BYTE PTR [ecx+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3941 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[ebp]
	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN106@Reallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN103@Reallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	edi, edx
$LN106@Reallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3950 : 		return (*this);

	mov	DWORD PTR [ebx], esi
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 3951 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN103@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	ebx
	push	esi
	call	_memcpy

; 506  : 		_Left = _Right;

	mov	cl, BYTE PTR _<_Args_0>$[ebp]

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH

; 506  : 		_Left = _Right;

	mov	BYTE PTR [edi], cl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3950 : 		return (*this);

	mov	eax, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\iosfwd

; 506  : 		_Left = _Right;

	mov	BYTE PTR [edi+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3950 : 		return (*this);

	mov	DWORD PTR [ebx], esi
	pop	edi
	pop	esi
	pop	ebx

; 3951 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN127@Reallocate:

; 3924 : 			{
; 3925 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN125@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))
; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

	pop	ebp
	ret	0
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT
; __Val$ = ecx

; 330  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 331  : 	}

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstddef
;	COMDAT ??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPBV?$codecvt@DDU_Mbstatet@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPBV?$codecvt@DDU_Mbstatet@@@0@ABV10@@Z PROC ; std::addressof<std::codecvt<char,char,_Mbstatet> const >, COMDAT
; __Val$ = ecx

; 330  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 331  : 	}

	ret	0
??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPBV?$codecvt@DDU_Mbstatet@@@0@ABV10@@Z ENDP ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT
; __Bytes$ = ecx

; 181  :  #if defined(_M_IX86) || defined(_M_X64)
; 182  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN2@Allocate

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 52   : 		return (::operator new(_Bytes));

	add	esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN11@Allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 194  : 	}

	ret	0
$LN11@Allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Allocate:

; 183  : 		{	// boost the alignment of big allocations to help autovectorization
; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));
; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN3@Allocate

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 194  : 	}

	ret	0
$LN3@Allocate:

; 189  : 		{
; 190  : 		return (_Traits::_Allocate(_Bytes));
; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

	xor	eax, eax

; 194  : 	}

	ret	0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT
; __Ptr$ = ecx
; __Bytes$ = edx

; 200  :  #if defined(_M_IX86) || defined(_M_X64)
; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN13@Deallocate

; 115  : 	_Bytes += _Non_user_size;

	push	esi

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	esi, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	ecx, esi

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [ecx-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN10@Deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, esi
	pop	esi
$LN13@Deallocate:

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 208  : 	}

	ret	0
$LN10@Deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN15@Deallocate:
	int	3
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??$_Refancy@PAD$0A@@std@@YAPADPAD@Z
_TEXT	SEGMENT
??$_Refancy@PAD$0A@@std@@YAPADPAD@Z PROC		; std::_Refancy<char *,0>, COMDAT
; __Ptr$ = ecx

; 363  : 	return (_Ptr);

	mov	eax, ecx

; 364  : 	}

	ret	0
??$_Refancy@PAD$0A@@std@@YAPADPAD@Z ENDP		; std::_Refancy<char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_classSize$dead$ = 8					; size = 4
?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEXI@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	ret	4
?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEXI@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vcruntime_exception.h
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 68   :     {

	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 67   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7bad_cast@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT
; _this$ = ecx

; 2312 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 2322 : 		pointer _Ans = get();
; 2323 : 		this->_Myptr() = pointer();

	mov	DWORD PTR [ecx], 0

; 2324 : 		return (_Ans);
; 2325 : 		}

	ret	0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 2293 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2312 : 		return (this->_Myptr());

	mov	ecx, DWORD PTR [ecx]

; 2294 : 		if (get() != pointer())

	test	ecx, ecx
	je	SHORT $LN22@unique_ptr

; 2081 : 		{	// delete a pointer

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2082 : 		static_assert(0 < sizeof (_Ty),
; 2083 : 			"can't delete an incomplete type");
; 2084 : 		delete _Ptr;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN22@unique_ptr:

; 2295 : 			{
; 2296 : 			this->get_deleter()(get());
; 2297 : 			}
; 2298 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch, COMDAT
; _this$ = ecx

; 222  : 		{	// get duration from epoch

	push	ebp
	mov	ebp, esp

; 223  : 		return (_MyDur);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 224  : 		}

	pop	ebp
	ret	4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT
; _this$ = ecx

; 104  : 		return (_MyRep);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 105  : 		}

	ret	0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 1784 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1787 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 4004 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 3866 : 		{	// determines the next array size to allocate

	push	ebp
	mov	ebp, esp

; 3867 : 		const size_type _Max = max_size();
; 3868 : 		auto& _My_data = this->_Get_data();
; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	edx, DWORD PTR __Requested$[ebp]
	or	edx, 15					; 0000000fH
	push	esi
	cmp	edx, 2147483647				; 7fffffffH

; 3870 : 		if (_Masked > _Max)

	ja	SHORT $LN25@Calculate_

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);
; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;

	mov	esi, DWORD PTR [ecx+20]

; 3876 : 		if (_Old > _Max - _Old / 2)

	mov	eax, 2147483647				; 7fffffffH
	mov	ecx, esi
	shr	ecx, 1
	sub	eax, ecx
	cmp	esi, eax
	ja	SHORT $LN25@Calculate_

; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	lea	eax, DWORD PTR [ecx+esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	edx, eax
	pop	esi
	cmovb	edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring

; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	mov	eax, edx

; 3882 : 		}

	pop	ebp
	ret	4
$LN25@Calculate_:

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);

	mov	eax, 2147483647				; 7fffffffH
	pop	esi

; 3882 : 		}

	pop	ebp
	ret	4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr, COMDAT
; _this$ = ecx

; 2159 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 2160 : 		}

	ret	0
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\memory
;	COMDAT ?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter, COMDAT
; _this$ = ecx

; 2149 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 2150 : 		}

	ret	0
?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\memory
;	COMDAT ?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get, COMDAT
; _this$ = ecx

; 2312 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 2313 : 		}

	ret	0
?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT
; _this$dead$ = ecx

; 2081 : 		{	// delete a pointer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2082 : 		static_assert(0 < sizeof (_Ty),
; 2083 : 			"can't delete an incomplete type");
; 2084 : 		delete _Ptr;

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN3@operator:

; 2085 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1857 : 			{	// user-provided, for fancy pointers
; 1858 : 			}

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second, COMDAT
; _this$ = ecx

; 302  : 		return (_Myval2);

	mov	eax, ecx

; 303  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT
; _this$ = ecx

; 292  : 		return (*this);

	mov	eax, ecx

; 293  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr, COMDAT
; _this$ = ecx

; 2164 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 2165 : 		}

	ret	0
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second, COMDAT
; _this$ = ecx

; 307  : 		return (_Myval2);

	mov	eax, ecx

; 308  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\memory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT
; _this$ = ecx

; 2212 : 		{	// construct with pointer

	push	ebp
	mov	ebp, esp
	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\memory

; 2213 : 		}

	pop	ebp
	ret	4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
;	COMDAT ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 308  : 	{	// subtract two durations

	push	ebp
	mov	ebp, esp

; 309  : 	using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 310  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	mov	eax, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	sub	esi, DWORD PTR [eax]

; 88   : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx], esi

; 309  : 	using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 310  : 	return (_CD(_CD(_Left).count() - _CD(_Right).count()));

	sbb	edx, DWORD PTR [eax+4]
	mov	eax, ecx

; 88   : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	DWORD PTR [ecx+4], edx

; 311  : 	}

	pop	esi
	pop	ebp
	ret	0
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\chrono
;	COMDAT ??$?0NX@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QAE@ABN@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0NX@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QAE@ABN@Z PROC ; std::chrono::duration<double,std::ratio<1,1> >::duration<double,std::ratio<1,1> ><double,void>, COMDAT
; _this$ = ecx

; 89   : 		{	// construct from representation

	push	ebp
	mov	ebp, esp

; 88   : 			: _MyRep(static_cast<_Rep>(_Val))

	mov	eax, DWORD PTR __Val$[ebp]
	movsd	xmm0, QWORD PTR [eax]

; 90   : 		}

	mov	eax, ecx
	movsd	QWORD PTR [ecx], xmm0
	pop	ebp
	ret	4
??$?0NX@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QAE@ABN@Z ENDP ; std::chrono::duration<double,std::ratio<1,1> >::duration<double,std::ratio<1,1> ><double,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT
; __Arg$ = ecx

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1575 : 	}

	ret	0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT
; __Bytes$ = ecx

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 95   : 		{	// add overflow, try allocating all of memory and assume the
; 96   : 			// allocation function will throw bad_alloc
; 97   : 		_Block_size = static_cast<size_t>(-1);
; 98   : 		}
; 99   : 
; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 52   : 		return (::operator new(_Bytes));

	add	esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN7@Allocate_m

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 105  : 
; 106  :   #ifdef _DEBUG
; 107  : 	static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 108  :   #endif /* _DEBUG */
; 109  : 	return (_Ptr);
; 110  : 	}

	ret	0
$LN7@Allocate_m:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\memory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\memory
;	COMDAT ??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>, COMDAT
; _this$ = ecx

; 2144 : 		{	// construct with compatible pointer

	push	ebp
	mov	ebp, esp
	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\memory

; 2145 : 		}

	pop	ebp
	ret	4
??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT
; _this$ = ecx

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _<_Val2_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 278  : 		{	// construct from forwarded values
; 279  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\type_traits
;	COMDAT ??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z
_TEXT	SEGMENT
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z PROC ; std::forward<std::_Facet_base * &>, COMDAT
; __Arg$ = ecx

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1575 : 	}

	ret	0
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ENDP ; std::forward<std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
	sub	ecx, DWORD PTR [ecx-4]
	jmp	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
END
